\chapter{Evaluierung inkl. Bewertungskriterien}
Ein Cross-Plattform-Entwicklungsframework lässt sich am besten beurteilen, indem die Qualität
eines Software-Produkts, das mit dieser Technologie entwickelt wurde, bewertet wird. Im vorliegenden
Fall ist es die Scan-App.\\\textbf{ISO/IEC 9126} definiert Software-Qualität als:\\ \emph{
Gesamtheit von Merkmalen und Merkmalswerten eines Software-Produkts, die sich auf dessen Eignung
beziehen, festgelegte oder vorausgesetzte Erfordernisse zu erfüllen}.
\newline[\cite{ISO9126}]
\\Um die Qualität eines
Software-Produkts bewerten zu können, werden möglichst objektive prüfbare Kriterien benötigt.
\section{Goal-Question-Metric}
% Als immaterielles Gut scheint Software nicht fassbar zu sein.
Während bei der Kaufentscheidung
für ein materielles Produkt gemessene oder prognostizierte Werte herangezogen werden können, gibt es
bei Software, als immaterielles Gut, keine solche Werte. Nach \cite{SE} werden quantifizierte
Aussagen über Produkte oder Entwicklungsprozesse als Metriken bezeichnet. Es ist allerdings keine einfache Aufgabe, geeignete
Metriken zu identifizieren.
Nach dem Goal-Question-Metric Ansatz (GQM) werden die zu erhebenden Metriken aus den Problemen,
Zielen und Fragen abgeleitet [\cite[321]{SE}]. Dieser Ansatz besteht aus drei Schritten:
\begin{itemize}
  \item[1] Definition von Relevanten Ziele.
  \item[2] Aus jedem Ziel werden Fragen abgeleitet, mit derer Hilfe überprüft werden kann ob das
  Ziel erreicht ist.
  \item[3] Für jede Frage werden Metriken festgelegt, die dazu beitragen, die Antworten zu finden.
\end{itemize}
Mithilfe dieses Ansatzes werden Metriken abgeleitet, die die Messung der Software
Qualität der Scan-App und damit die Evaluierung von Xamarin als Cross-Plattform-Entwicklungstool erleichtern
können.
\section{Bewertungskriterien nach ISO-Norm 9126}\label{BewertungskriterienISO}
Im Folgenden werden Qualitätsmerkmale nach \textbf{ISO-Norm 9126} vorgestellt (siehe
Abb.\ref{fig:abb38}). Anhand dieser Kriterien wird die App bewertet.
 
% In Abb.\ref{fig:abb38} werden die ISO-Norm 9126
% Softwarequalitätsmerkmale abgebildet.
\begin{figure}[!h]
\centering
\includegraphics[scale = 0.805]{graphics/ISO_9126_Grafik.png}
\caption{Softwarequalität nach ISO-Norm 9126 [\cite{SWQGrafikWiki}]}
\label{fig:abb38}
\end{figure}
\subsection{Funktionalität}
Für die Bewertung der Funktionalität lassen sich folgende Metriken ableiten:
  \\\textbf{Ziel}: UI-Konzept - die von der Entwicklungsplattform bereitgestellten UI-Tools,
  sollen die Funktionalität einer nativ entwickelten App gewährleisten können.
  \\\textbf{Frage}: Wie viele angeforderten Funktionalitäten konnten nicht erfüllt werden,
  aufgrund fehlender APIs? 
  \\\textbf{Metrik M1}: Anzahl der Funktionen, die nicht unterstützt wurden. 
 \\Cross-Plattform-Entwicklung bringt viele Vorteile, allerdings passiert das nicht selten auf
  Kosten der Funktionalität. Wie im Kapitel \ref{StandDerTechnik} erläutert, sind bspw. die Möglichkeiten
  einer Web App begrenzt, so dass nur Web Apps mit einfach zu realisierende Funktionalität
  plattformübergreifend entwickelt werden können. Je kleiner der Wert dieser Metrik, desto besser.
  \\Im vorliegenden Fall gab es einige anspruchsvolle Anforderungen an die App, wie die
  Scanner-Funktion, das Persistieren der Appdaten oder die Benutzung des Verschüsselungsalgorithmus
  SHA-256 für die Generierung eines URI Adresszusatzes für die Web Services.
   Dank C\#  und der Möglichkeit, NuGet Packages und Xamarin Konponenten anzubinden konnten alle
   angeforderten Funktionalitäten umgesetzt werden. Daraus ergibt sich: \textbf{Wert von M1 = 0}.
   \\
 \\\textbf{Ziel}:Das Framework soll Zugriff auf native Elemente, wie bspw. die Kamera eines
 Smartphones ermöglichen.
  \\\textbf{Frage}: Wie oft wird auf die Kamera zugegriffen?
  \\\textbf{Metrik M2}: Die Anzahl der Zugriffe auf die Kamera des Smartphones. 
  \\Wenn der Wert dieser Metrik größer Null ist, ist es ein Indiz dafür, dass mindestens eine
  hardwarenahe Funktionalität angefordert und gewährleistet wurde.
  \\Es wird einmal auf die Kamera zugegriffen, nämlich beim Scannen. Dieses Feature wurde durch
  die Xamarin Komponente ZXing.Net.Mobile ermöglicht. \textbf{Wert von M2 = 1}.
\subsubsection{Interoperabilität}
Die Kommunikation zwischen der App und dem Server wurde auf verschiedene Szenarien getestet. Es
wurde sichergestellt, dass die App nicht abstürzt, wenn der Server nicht erreichbar ist. Daraus
lässt sich ableiten, dass die benötigten Mechanismen, um eine Verbindung mit einem Server
herzustellen und zu pflegen, von Xamarin zur Verfügung gestellt wurden.
\subsubsection{Sicherheit}
Ein besonders wichtiges Kriterium für eine Business App. Anwendungen dieser Kategorie benutzen oft
Web Services und es werden sensible Daten über das Internet übertragen. Aus diesem Grund ist es sehr
wichtig, dass solche Daten über sichere Kanäle übertragen werden.\\Mithilfe des GQM-Anstatzes
lässt sich folgende Metrik ableiten: 
\\\textbf{Ziel}:Das Framework soll die Benutzung von
Verschlüsselungsalgorithmen ermöglichen.
  \\\textbf{Frage}: Wie oft wurde ein Verschlüsselungsalgorithmus angewendet?
  \\\textbf{Metrik M3}: Die Anzahl der Fällen, in denen ein Verschlüsselungsalgorithums angewendet
  wurde.\\Je größer der Wert dieser Metrik ist, desto sicherer ist die mobile Anwendung.
\\Für eine sichere Kommunikation mit dem Backend generiert die App mithilfe des
Verschlüsselungsalgorithmus SHA-256 einen Adresszusatz für die Web Services URI. Das passiert bei
der einmaligen Registrierung eines Benutzers und beim absenden einer Bestellung. Daraus lässt sich
folgender Wert dieser Metrik berechnen: \textbf{Wert von M3 =2}. 
\\Darüber hinaus wird das Https Protokol benutzt. In diesem Fall lässt sich einer der größten
Vorteile der Benutzung von einer mächtigen Programmiersprache, wie C\# beobachten, Kriterium erfüllt.
\subsubsection{Richtigkeit}
%Sind alle geforderten Funktionen implementiert worden?
Im vorangegangenen Kapitel wurden Anforderungen an die App spezifiziert und anschließend
wurde die Anwendung nach diesen Kriterien getestet. D.h. alle geforderten Funktionen sind in beiden
Versionen der App (iOS und Android) implementiert und getestet worden und somit ist dieses Kriterium
erfüllt.
\subsection{Zuverlässigkeit}
Dank Xamarin Test Cloud wurde die Zuverlässigkeit der Scan-App getestet. Aufgrund der großen
Vielfalt an Smartphones wurde besonders bei der Android Version darauf geachtet, dass die
App auf möglichst vielen Geräten getestet wird. Es wurden unterschiedliche Szenarien durchgespielt,
die eventuell zum Absturz der App führen könnten. Es wurde das Verhalten der Anwendung beobachtet,
wenn bspw. die Internetverbindung während einer Anfrage an den Server unterbrochen wird, oder bei
einem unerwarteten Ausschalten des Telefons. Es durften keine zuvor
gespeicherten Daten verloren gehen. Da beide Versionen (iOS und Android) der App die Tests
erfolgreich abgeschlossen haben, kann das Kriterium Zuverlässigkeit als erfüllt vermerkt werden.
\subsection{Benutzbarkeit}
Benutzbarkeit (Usability) ist ein weiterer, besonders für mobile Anwendungen wichtiges Kriterium,
das eine App erfüllen muss, damit sie Erfolg auf dem Markt haben kann. Für die Scan-App wurde eine
intuitive Benutzbarkeit angestrebt.
Für die Menüpunkten wurden aussagekräftigen Namen ausgewählt und an vielen Stellen werden
Hinweistexte in Form von Popup Fenster angezeigt, so dass für die Benutzung der Anwendung keine
Schulung vorausgesetzt wird.
Mit dem GQM Ansatz lässt sich folgende Metrik ableiten:
\\
  \\\textbf{Ziel}: Eine "`cross-plattform"' entwickelte App soll nicht deutlich langsamer als
  eine nativ entwickelte Referenz-Applikation sein.
  \\\textbf{Frage}: Wie lange braucht der Scanner von ScanApp um eine Barcodenummer zu erfassen?
  \\\textbf{Metrik M4}: 
  \fbox{
      $\frac{\textrm{Die Zeit in Sekunden, die der Scanner braucht um einen
      Barcode zu scannen}}{\textrm{Zeit, die die Referenzapp braucht um einen Barcode zu
     scannen}}$
  }
  \\Angestrebter Wert dieser Metrik wäre die Eins. Das würde bedeuten, dass eine
  plattformübergreifend entwickelte App nicht nur die Funktionalität einer nativ entwickelten App
  aufweist, sondern auch eine ähnlich gute Performanz hat.
%      $\frac{\textrm{Die Zeit in Sekunden, die der Scanner braucht um einen Barcode zu
%      scannen}}{\textrm{Zeit, die eine native Scanner-App braucht um einen Barcode zu
%      scannen}}$
%      \noindent\hspace*{20mm} 15,71 cm /$ \frac {6 ms (\textrm{Zeit pro Umdrehung})} {533,3 \mu}$\\ 
% Die Zeit in Sekunden, die der Scanner 
%   braucht um einen Barcode zu scannen im Vergleich zu der Zeit, die eine native Scanner-App braucht.
   \\Für die Erfassung eines Barcodes wurden bei der Scan-App zwischen 2 und 5
   Sekunden gemessen. Bei einer nativen Scanner App wurden ähnliche Zeiten gemessen, wobei die
   native App unwesentlich schneller war (2 bis 4 Sekunden).\\Daraus lässt sich der \textbf{Wert
   von M4 = 0.85} berechnen.
\subsection{Effizienz}
Die mobilen Geräte werden immer leistungsfähiger, allerdings aufgrund der großen hochauflösenden
Displays halten die Akkus nicht besonders lange. Aus diesem Grund werden Anwendungen, die zu viele
Ressourcen und dadurch Akku im Hintergrund verbrauchen, oft von den Benutzern abgelehnt, auch wenn
die Apps sonst fehlerfrei funktionieren.\\Xamarin.Forms bietet die Möglichkeit die Methoden
\textit{onStart(), onSleep() und onResume()} zu überschreiben und somit lässt sich das Verhalten der
App steuern, wenn die Anwendung im Hintergrund gerät.\\Bei der Entwicklung der App wurde explizit darauf geachtet, dass die
Kommunikation mit dem Server in separaten Threads ausgeführt wird, so dass die App nicht "`hängen
bleibt"', wenn die Internetverbindung langsam oder gar nicht da ist. Wie im vorangegangenen
Kapitel bereits erörtert, gibt Xamarin die Möglichkeit zwischen verschiedenen Arten von mobilen
Internetverbindungen zu unterscheiden, dadurch lassen sich Ressourcen sparen. 
\\Es lässt sich
zusammenfassen, dass Xamarin die benötigten Mechanismen bereitstellt, sodass Entwickler dieses
Kriterium erfüllen können.
\subsection{Änderbarkeit}
Ein besonders wichtiges Kriterium in Hinsicht auf plattformübergreifende App-Entwicklung. Der Sinn,
mobile Anwendungen "`cross platform"' zu entwickeln, ist es die Aufwände zu minimieren, und zwar
nicht nur während der Entwicklungsphase, sondern auch während der Wartung. Die App Pflege soll
möglichst plattformübergreifend erfolgen. Dasselbe gilt für die Erweiterung der Anwendung,
Änderungen sollen an einer zentralen Stelle vorgenommen werden und trotzdem die gewünschten
plattformspezifischen Auswirkungen haben.\\Die "`Hamburger"'-Menüführung der App erlaubt
eine Änderung oder Erweiterung des Menüs um beliebig viele neue Menüpositionen.
Aufgrund der gemeinsamen Logik lassen sich Änderungen und Fehlerkorrekturen der App mit möglichst
wenig Aufwand im gemeinsamen Projekt vornehmen. Wie bereits erwähnt werden die Layouts der Ansichten
automatisch an die Bildschirmgröße des konkreten Smartphones angepasst. Durch die lose Kopplung zwischen View und
Viewmodel beim MVVM-Muster lässt sich eine Ansicht mit minimalem Aufwand durch eine
andere austauschen, und zwar plattformübergreifend.\\Mit dem Ansatz vom GQM wurden folgende Metriken
abgeleitet:
% Es lässt sich schließen, dass die Scan-App und dadurch Xamarin.Forms dieses Kriterium erfüllt.
\\
\\\textbf{Ziel}: Es soll eine plattformübergreifende Programmiersprache benutzt werden.
\\\textbf{Frage}: Wie viele Programmiersprachen wurden für die
 Implementierung der iOS-Version, der Android-Version der App und für die Implementierung des
 gemeinsamen plattformübergreifenden Teils verwendet?
\\\textbf{Metrik M5}: Die Anzahl der verwendeten Programmiersprachen.\\Der angestrebte Wert dieser
Metrik ist die Zahl Eins.
\\Es wurde lediglich C\# angewendet (Für die Beschreibung der GUI wird auch XAML angewendet,
allerdings lässt sich die GUI auch komplett in C\# definieren).\\\textbf{Wert von M5 = 1}.
\\
  \\\textbf{Ziel}: Geschäftslogik soll einmal in dem gemeinsamen Projekt implementiert werden
  und nicht in den plattformspezifischen Projekten.
  \\\textbf{Frage}: Für die Realisierung von wie viele Features mussten "`Custom Renderer"'
  benutzt werden? 
  \\\textbf{Metrik M6}: Anzahl der "`Custom Renderer"'. \\Der Wert dieser Metrik ist proportional zu
  den Aufwänden, die für einen Entwickler entstehen, wenn ein neues Feature implementiert werden
  soll. Aus diesem Grund wird ein möglichst kleiner Wert angestrebt.
  \\Die ganze App-Logik und Gestaltung der GUI wurde im gemeinsamen Projekt definiert und es wurden keine benutzerdefinierte Renderer in die
  plattformspezifischen Projekten benötigt. Für diese Metrik ergibt sich: \textbf{Wert von M6 = 0}.
  \\
  \\\textbf{Ziel}: Der Großteil des Codes soll im gemeinsamen Projekt sein.
  \\\textbf{Frage}: Wie viel Prozent des Codes befinden sich im plattformübergreifenden Projekt?
  \\
  \\\textbf{Metrik M7}: 
  \fbox{
      $\frac{\textrm{LOC (lines of code) im plattformübergreifenden Shared Projekt}}{\textrm{LOC
      von allen drei Projekte gesamt.}}$ }
      \\
      \\Idealer Wert dieser Metrik wäre 1, bzw. 100\%.
%   Prozentsatz von LOC (lines of code) im plattformübergreifenden aus LOC
%   von allen drei Projekte gesamt. 
  \\Über 95\% des gesamten Codes befindet sich im geteilten Projekt. Dieser Wert wurde
  fogendermassen berechnet:\\
  \\ $\frac{\textrm{"`shared"' ScanApp = ca. 7050 LOC}}{\textrm{("`shared"' ScanApp =
 ca. 7050) + (ScanApp.Droid = ca. 150) + (ScanApp.iOS = ca. 200) LOC}}$ 
 \\
 \\\textbf{Wert von M7 = 0.95}.
\subsection{Übertragbarkeit}
Das wichtigste Kriterium aus Cross-Plattform-Sicht. Das Ziel von plattformübergreifende
App-Entwicklung ist es, die gleiche Anwendung auf mehreren Plattform übertragen zu können. 
Mit dem GQM-Ansatz lässt sich folgende Metrik ableiten:
\\
  \\\textbf{Ziel}: Eine mit Xamarin entwickelten App soll für mehrere mobilen Betriebssystem
  verfügbar sein. 
  \\\textbf{Frage}: Wie viele plattformspezifische Versionen der App sind aus der gemeinsamen
  Codebasis entstanden? 
  \\\textbf{Metrik M8}: Anzahl der Plattformen, für die die Xamarin-App verfügbar ist.
  \\Je größer die Anzahl der mobilen Betriebssystemen, für die eine Version der App entstanden ist,
  desto besser. Im vorliegenden Fall ist der Wert der Metrik gleich zwei (iOS und Android).
  Allerdings wäre mit einem Xamarin Business-Account auch die Entwicklung einer weiteren Version der
  App möglich, nämlich eine Windows Phones Version. D.h. der Wert der Metrik könnte auch drei sein.
  \textbf{Wert von M8 = 2}.
  \\
\\Durch die Distribution der ScanApp in die entsprechenden App-Stores (Apples App Store und Androids
Google Play Store) kann die Scan-App auf die für mobile Anwendungen übliche Art und Weise verbreitet werden. Mit
dem GQM-Ansatz lässt sich folgende Metrik ableiten:
\\
  \\\textbf{Ziel}: Die Distribution einer mit Xamarin entwickelten Anwendung in die
  entsprechenden App-Stores soll mit einem ähnlich großen Aufwand verbunden sein, wie die Distribution einer nativen App.
  \\\textbf{Frage}: Wie viel Zeit nimmt das Hochladen einer Xamarin App in den App Store und
  Google Play Store in Anspruch?
  \\\textbf{Metrik M9}: Benötigte Zeit für die Distribution einer Xamarin App in Apples App Store.
  \\\textbf{Metrik M10}: Benötigte Zeit für die Distribution einer Xamarin App in Androids Google Play Store.
  \\Angestrebt wird, dass der Wert dieser Metrik weniger als eine Stunde ist.
  \\Für die Konfiguration der benötigten Einstellungen und die Erstellung einer Android APK-Datei,
  bzw. einer iOS IPA-Datei durch Xamarin Studio werden typischerweise jeweils 15 bis 30 Minuten
  gebraucht. Das anschließende Hochladen in die jeweiligen Stores unterscheidet sich nicht von dem Hochladen einer
  nativen iOS- oder Android-App und wird ebenso innerhalb 15 bis 30 Minuten erledigt.
  \\\textbf{Wert von M9: ca 45 Minuten}.\\\textbf{Wert von M10: ca 45 Minuten}
   \\
  \\\textbf{Ziel}: Die Installationsdatei (APK-Datei bei Android und IPA-Datei bei iOS) sollte
  nicht deutlich größer als die Installationsdatei einer nativ entwickelten App .
  \\\textbf{Frage}: Wie groß ist die Installationsdatei einer mit Xamarin erstellten App im
  Vergleich zu der Größe der Installationsdatei der Referenzapplikation?  
  \\
  \\\textbf{Metrik M11}: 
  \fbox{
      $\frac{\textrm{Größe der IPA-Installationsdatei der Xamarin Scan-App im App
      Store}}{\textrm{Größe der IPA-Datei der Referenzapplikation im App Store}}$ }
      \\
      \\Da die Referenzapplikation nur eine iOS Version hat, lässt sich diese Messung nur für die
      iOS Version der Scan-App durchführen. Idealer Wert dieser Metrik wäre 1. Es wäre
      wünschenswert, dass die Xamarin App nicht deutlich größer als die Referenzapplikation ist.
      Es soll allerdings beachtet werden, dass die Xamarin Scan-App um einige Features erweitert
      wurde, mit dem Ziel, eine möglichst größere Gruppe von Enterprise-Apps zu repräsentieren, so
      dass die Evaluierung von Xamarin als Cross-Plattform-Entwicklungsframework objektiver wird. Aus diesem
      Grund ist es zu erwarten, dass die Installationsdatei der Xamarin App größer als die der
      Referenzapplikation ist.
%   Prozentsatz von LOC (lines of code) im plattformübergreifenden aus LOC
%   von allen drei Projekte gesamt. 
  \\
  \\ \textbf{M11 = }$\frac{\textrm{43.7 MB}}{\textrm{1.5 MB}}$ \textbf{ = 29.1}
\subsection{Auswertung der gemessenen Werte}
In Tabelle \ref{table3} werden die gemessenen Werte der mit dem GQM-Ansatz abgeleiteten Metriken
zusammengefasst. In der Spalte Auswertung wurde ein "`+"' eingetragen, wenn der Wert der
Metrik sich dem angestrebten Wert genähert hat und ein "`-"', wenn der Wert der Metrik nicht
befriedigend war.
\\Wie aus der Tabelle ersichtlich, sind die Auswertungen der meisten Metriken positiv
ausgefallen. Bei Metrik M11 ist das allerdings nicht der Fall gewesen. Der Wert dieser Metrik ließ
sich nur bei der iOS Version der App ermitteln, weil die Anwendung, die als Vorlage für die Scan-App
gedient hat, nur für iOS verfügbar war. 
% \\Die Größe der
% APK-Installationsdatei der Android Version der App ließ sich mit der APK-Dateigröße anderer
% ähnlichen Apps vergleichen.
\\Die Größe der APK-Datei der Android Version der Scan-App im Google Play Store beträgt 18 MB.
Vergleichbare Apps haben eine deutlich kleinere APK-Datei (1 bis 5 MB). Daraus lässt sich
 schießen, dass Xamarin Apps im Allgemeinen deutlich grösser als nativ erstellte Apps sind.
\begin{table}
\begin{tabular}{|l|l|l|l|l|}
\hline
\textbf{Metrik} & \textbf{Wert} & \textbf{Auswertung} \\\hline 
\textbf{M1: }{\footnotesize Anzahl der angeforderten Funktionen, die nicht realisiert werden} & 0 &
+
\\
{\footnotesize konnten} &  &  \\
\hline
\textbf{M2: }{\footnotesize Anzahl der Zugriffe auf die Kamera des Smartphones} & 1 & + \\
\hline
\textbf{M3: }{\footnotesize Anzahl der Fälle, in denen ein Verschlüsselungsalgorithmus} & 2 & +
\\
{\footnotesize angewendet wurde} &  &  \\
\hline
\textbf{M4: }{\footnotesize Verhältnis der Zeit in Sekunden, die der Scanner benötigt um} & 0.85 &
+
\\
{\footnotesize einen Barcode einzuscannen zu der Zeit, die eine} &  & 
\\
{\footnotesize nativ entwickelte Scanner-App für denselben Vorgang benötigt} &  & 
\\
\hline
\textbf{M5: }{\footnotesize Anzahl der verwendeten Programmiersprachen} & 1 & + \\
\hline
\textbf{M6: }{\footnotesize Anzahl der benutzerdefinierten Renderer} & 0 & + \\
\hline
\textbf{M7: }{\footnotesize Verhältnis der LOC (lines of codes) des gemeinsamen Codeanteils} & 0.95
& +
\\
{\footnotesize zu der LOC des ganzen Codes} &  & 
\\
\hline
\textbf{M8: }{\footnotesize Anzahl der Plattformen, für die die Xamarin App verfügbar ist} & 2 & +
\\
\hline
\textbf{M9: }{\footnotesize Benötigte Zeit für das Exportieren einer iOS IPA-Datei}
& 45 Min.
& +
\\
{\footnotesize und anschließend das Hochladen in den Apples App Store} &  & \\
\hline
\textbf{M10: }{\footnotesize Benötigte Zeit für das Exportieren einer Android APK-Datei}
& 45 Min.
& +
\\
{\footnotesize und anschließend das Hochladen in den Google Play Store} &  & \\
\hline
\textbf{M11: }{\footnotesize Verhältnis der Größe einer Xamarin App Installationsdatei}
& 29.1
& -
\\
{\footnotesize zu der Größe der Installationsdatei der Referenzapplikation} &  & \\
\hline
\end{tabular}
\caption{Zusammenfassung der berechneten Werte aller Metriken}
\label{table3}
\end{table}
% \begin{itemize}
%   \item Es soll eine plattformübergreifende Programmiersprache benutzt werden.
%   \item Gute Unterstützung durch IDE.
%   \item Das Framework soll Zugriff auf native Elemente, wie bspw. die Kamera eines Smartphones
%   ermöglichen.
%   \item Klare Trennung zwischen UI und Business Logik.
%   \item Code-Sharing: Der Code-Sharing Anteil soll mehr als 50\% des Gesamtcodes sein.
%   \item Geschäftslogik soll einmal in dem gemeinsamen Projekt implementiert werden und nicht in den
%   plattformspezifischen Projekten.
%   \item UI-Konzept - die von der Entwicklungsplattform bereitgestellten UI-Tools, sollen die
%   Funktionalität einer nativ entwickelten App gewährleisten können.
%   \item Persistieren der Daten (Datenbankanbindung) soll unterstützt werden.
%   \item Es sollen möglichst wenig Bugs während des Entwicklungsprozesses entstehen und deren
%   Behebung soll nicht mit viel Aufwand verbunden sein.
%   \item Die mit Xamarin entwickelte mobile Anwendung soll keine funktionale Unterschiede zu einer
%   nativen Applikation aufweisen.
%   \item Soll nicht deutlich langsamer als die Referenz Applikation sein.
%   \item Die Distribution einer mit Xamarin entwickelten Anwendung in die entsprechenden App-Stores
%   soll mit einem ähnlich großen Aufwand verbunden sein, wie die Distribution einer nativen App.
% \end{itemize}
\section{Weitere Feststellungen}
\subsection{Positive Feststellungen}
Es lässt sich zusammenfassen, dass Xamarin als Cross Plattform Entwicklungstool, bzw. Xamarin Studio
als Entwicklungsumgebung (IDE), sich kaum von den herkömmlichen Entwicklungsumgebungstools, wie
Eclipse oder Xcode unterscheidet. Mit Xamarin.UITest verfügt Xamarin über ein integriertes
Werkzeug zum Ausführen und Auswertung von automatisierten UI-Tests. Darüber hinaus lassen sich Open
Source Bibliotheken, wie Xamarin Components oder NuGet Packages hinzufügen. Wie es sich für eine
gute Entwicklungsumgebung gehört, verfügt die IDE über "`Autocomplete"'- und "`Debug"'-Funktionen.
\\Es muss erwähnt werden, dass das Team von Xamarin sich
große Mühe für die Weiterentwicklung des Frameworks gibt.
Wenn Apple, bspw. neue APIs vorstellt, können sie innerhalb weniger Stunden mit Xamarin verwendet
werden.
Es finden regelmäßige Updates und Bugfixes statt.
\subsection{Negative Feststellungen}\label{NegativeFeststellungen}
\subsubsection{MVVM}
Aufgrund der nicht sehr ausführlichen Informationen auf der offiziellen Seite von Xamarin ist es
keine einfache Aufgabe, sich an dem MVVM-Architekturmuster zu halten. 
Es ist zu beobachten, dass in vielen der Beispielen aus dem Netz, die ganze Funktionalität einer
Ansicht(Xaml-Datei) in der dazugehörenden Code-Behind-Datei untergebracht wird, was die Idee
des MVVMs und die lose Kopplung zwischen View und Viewmodel zunichte macht. 
\\Für einen Entwickler ohne Erfahrung mit dem MVVM-Entwurfsmuster kann das sehr irreführend sein.
In den Beispielen, in denen das MVVM-Pattern sauber angewendet wird, werden oft lediglich einfache
Szenarien beschrieben, ohne komplizierte Interaktionen, wie z.B. Navigation zwischen den
Ansichten, so dass es für einen Anfänger eine richtige Strukturierung einer App zu einer
rätselhaften Aufgabe werden könnte. Es wird den Eindruck hinterlassen, dass Xamarin noch nicht ganz
ausgereift für MVVM ist.
\subsubsection{HTTPS}
Wie bereits erwähnt wird das Protokol https benutzt, um eine sichere Kommunikation mit dem
Backend, in einer unsicheren Umgebung, zu gewährleisten. Für die Nutzung von Web Services wird in
der Xamarin Comunity das NuGet Package \textit{Microsoft.Net.Http} empfohlen. Der in diesem Package
enthaltene Http-Client weist allerdings Schwächen auf, wenn die Kommunikation wie im vorliegenden
Fall nicht über http sondern über https erfolgen soll. Diese Schwächen sind kaum
dokumentiert und es kann lange dauern bis der Entwickler auf die Fehlerquelle kommt.
% \subsubsection{Die Größe der IPA-Datei}
% Die Datei ist größer als die IPA-Datei einer nativ entwickelten iOS-App.
\subsubsection{Xamarin Studio}
Es wurde beobachtet, dass bei Debuggen über einen längeren Zeitraum, Xamarin Studio hängen geblieben
ist und neugestartet werden musste. Allerdings muss angemerkt werden, das dies sehr selten
vorgekommen ist.
\subsubsection{Oberflächen-Designer}
Für Xamarin.iOS und Xamarin.Android gibt es ähnlich wie bei Eclipse und Xcode einen Designer für
die Erstellung der Bedienoberfläche, allerdings ist Xamarin noch nicht soweit, einen
Cross-Plattform-Designer anzubieten. Die Gestaltung der Ansichten erfolgt programmatisch,
meistens mit der Hilfe der Beschreibungssprache XAML.
% \subsubsection{Updates von Xamarin}
% Xamarin.iOS und Xamarin.Android werden ständig aktualisiert. In vielen Fällen ist es zu Problemen
% beim Kompilieren nach einem Update. 
\section{Grenzen der Cross-Plattform-Entwicklung}
Xamarin entwickelt sich mit raschem Tempo. Xamarin.iOS und Xamarin.Android bieten
.NET Entwicklern, die Möglichkeit Apps für iOS und Android zu entwickeln, die kaum von den
nativ entwickelten iOS- und Android-Apps zu unterscheiden sind. \\Interessant für die vorliegende
Arbeit ist der Ansatz von Xamarin.Forms. Wie im Kapitel \ref{ViewsUndLayouts}
bereits erläutert, haben Entwickler fünf verschiedenen Arten von Ansichten zur Auswahl, um  eine
Seite (Page) mit Xamarin.Forms zu erstellen. Für die Implementierung der ScanApp werden lediglich
ContentPages, NavigationPages und eine MasterDetailPage für die Menüsteuerung benutzt. \\Sollte es speziellere Anforderungen an der
Benutzungsoberfläche geben, müssen Entwickler benutzerdefinierte Renderer verwenden, um auf native
plattformspezifische SDK-Features zugreifen zu können. Allerdings befinden sich die Xamarin
Renderer-APIs noch in einer Bearbeitungsphase [\cite{XamarinCustomRenderer}] und allem Anschein nach
wird es noch einige Zeit dauern bis Xamarin die Mächtigkeit der herkömmlichen nativen App Entwicklung erreichen
kann.\\Es wurden oft die Vorteile der mächtigen .NET Plattform erwähnt, allerdings muss an dieser
Stelle beachtet werden, dass Xamarin nicht alle diese Vorteile nutzen kann, weil Xamarin nicht
direkt auf .NET basiert, sondern auf das Open Source Projekt Mono. D.h. Xamarin-Developer haben nur
eine Teilmenge der Funktionalitäten von .NET zur Verfügung.


