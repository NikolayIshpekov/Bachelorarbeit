\section{Implementierung und Test}
In diesem Abschnitt werden kurz Feststellungen beschrieben, die während der konkreten Realisierung
der Implementierung der ScanApp aufgefallen sind. Es werden noch typische Testvorgänge erläutert,
vor allem den Dienst von Xamarin - die Xamarin Test Cloud.
\\Die Benutzung von Xamarin mit Visual Studio erfordert einen Business-Account. Außerdem werden zwei
Rechner benötigt - ein Mac-Rechner als Build-Server  und ein Windows-PC auf dem Visual Studio läuft.
Aus diesem Grund fiel die Entwicklungsumgebungswahl für die Implementierung der Scan-App auf
Xamarin Studio. Xamarin Studio bietet mehrere Solution-Templates an
(siehe \ref{fig:abb36}).
\begin{figure}[!h]
\centering
\includegraphics[scale = 0.435]{graphics/XamarinStudioTemplate.png}
\caption{Xamarin Studio Solution Templates}
\label{fig:abb36}
\end{figure}
\subsection{Umsetzung des MVVM-Architekturmusters}
Wie bereits im Kapitel \ref{MVVM} erörtert, weist das MVVM-Pattern eine lose Kopplung
zwischen View und Viewmodel auf. Um diese Trennung visuell zu gestalten, werden drei Ordner erstellt:
\begin{itemize}
  \item \textbf{Model} - Im Ordner Model werden typischerweise Klassen defniert, die
  anwendungsspezifische Datentypen beschreiben. Das sind Klassen zur Speicherung und
  Verarbeitung von Daten, die dafür sorgen, dass die Daten konsistent gehalten
  werden.
  \item \textbf{View} - Alle Ansichten (Xaml-Datein, die vom Typ Xamarin.Forms.Page oder
Xamarin.Forms.View sind oder von diesen Klassen erben) gehören in den Ordner View.
  \item \textbf{Viewmodel} - In den Viewmodel-Ordner kommen die Viewmodel-Klassen (C\#-Klassen,
  die das Interface \textbf{\textit{INotifyPropertChanged}} implementieren). 
\end{itemize}
Jede Ansicht wird an ein Viewmodel gebunden. Das wird durch das sogenannte "`Data
Binding"' (in Deutsch Datenbindung) realisiert.
% In Abb.\ref{fig:abb23} sieht man eine typische
% Xaml-Datei, die eine Ansicht beschreibt und sich im Ordner View befindet. Diese Ansicht wird
% von der benutzerdefinierten Base\_Page abgeleitet, die ihrerseits von der Klasse Xamarin.Forms.Page
% abgeleitet wird.
 In einer C\#-Klasse, genannt Base\_Page, werden Eigenschaften und Methoden definiert, die für die
 meisten Ansichten gemeinsam sind. Bspw. das Navigationsheader-Logo oder Methoden für die Steuerung
der Navigation. Diese Klasse wird von der Klasse Xamarin.Forms.Page abgeleitet.
% \\Eine der wichtigsten Klassenvariablen der Klasse Xamarin.Forms.Page ist das Property
% \textit{BindingContext}.
% Mithilfe dieser Eigenschaft wird ein Viewmodel (in diesem Fall das HeaderDataEditViewModel) an der Page-Klasse gebunden (Siehe
% \ref{fig:abb23}, Zeile 23-25).
% \\In Zeile 12 findet eine typische Datenbindung ("`data binding"') statt.
% Das Text-Property eines Entry-Textfeldes wird an das Property \textit{Name} gebunden, das im
% Viewmodel definiert wird (siehe Abb.\ref{fig:abb33}).
% Sobald der Text des Textfelds sich ändert, wird das Viewmodel darüber informiert. Diese Bindung
% funktioniert in beiden Richtungen, d.h. Änderungen, die im Viewmodel vorgenommen werden, werden in
% der Ansicht angezeigt.\\In Abbildung \ref{fig:abb23}, Zeile 20 ist die Definition eines
% Toolbarbuttons zu sehen. Sobald dieser Button gedrückt wird, wird ein Command ausgeführt, das an
% das Property \textit{SaveUserDataCommand} des Viewmodels gebunden ist. D.h. dieses Klick-Event
% löst den Aufruf einer Methode in der Viewmodel-Klasse auf.\\Das Ganze veranschaulicht, welche
% Vorteile das MVVM-Architekturmuster mit sich bringt.
Durch die Datenbindung entsteht eine lose Kopplung zwischen View und ViewModel. Da das Viewmodel die
Views nicht kennt, lässt sich eine Ansicht problemlos durch eine andere austauschen. Die neue
Ansicht muss lediglich an das Viewmodel gebunden werden.
\\Ein ViewModel muss zwingend das Interface \textbf{\textit{INotifyPropertChanged}} implementieren.
Dadurch können sogenannte "`Bindable Properties"` definiert werden
%  (siehe Abb.\ref{fig:abb33})
. Bei jeder Änderung wird die OnPropertyChanged()-Methode mit dem Property-Name als String-Parameter
aufgerufen und dadurch wird ein PropertyChangedEventHandler ausgelöst.
\\Wie bei den meisten Applikationen, sind auch für die Scan-Anwendung mehrere Ansichten
erforderlich. Es stellt sich die Frage, wie wird zwischen den verschiedenen Seiten gewechselt?\\Um
zwischen den Ansichten navigieren zu können, wird eine Instanz der Klasse \textit{NavigationPage}
benötigt: \textit{new NavigationPage(new Page())}. 
\\Jede Xamarin.Forms.Page-Klasse hat über das Property \textbf{\textit{Navigation}} Zugriff auf das
NavigationPage: \textit{this.Navigation.PushAsync(new Page())}.\\Nach dem MVVM-Muster sollten sich
die Viewmodel-Klassen um die Navigation kümmern.
Allerdings ist \textit{Navigation} ein Property der Ansicht. D.h. das Viewmodel muss signalisieren,
dass es zu einer anderen Ansicht gewechselt werden soll. Da das Viewmodel die Ansicht nicht kennt,
kann das durch das \textbf{\textit{Xamarin.Forms Messaging Center}} erreicht werden. Die Ansicht
abonniert Navigationsnachrichten des Viewmodels und wird somit immer informiert, wenn die
Seite gewechselt werden soll.
\subsection{Anbindung der SQLite Datenbank}
Da beim gemeinsamen ScanApp Projekt keine Bibliotheken eingebunden werden können, muss man einen
SQLite.cs File aus Github herunterladen und in das gemeinsame Projekt kopieren. Dieser C\#-File
benutzt Compiler Direktiven um mehrere Plattformen in derselben Codebasis zu unterstützen.
\\Um SQLite in einer Xamarin.iOS oder Android Applikation benutzen zu können, muss man angeben, wo
der Datenbank File zu finden ist (es ist abhängig vom
Ziel-Plattform unterschiedlich). Für iOs und Android kann man "`Environment class"' benutzen um einen
validen Pfad zu konstruieren (siehe Abb. \ref{fig:abb27}). Mittels Compiler Direktiven lassen sich
spezielle Pfade für jede Plattform generieren.\\Um sicher zu gehen, dass der Code nicht versucht,
auf die SQLite Datenbank aus verschiedenen "`multiple Threads"' zuzugreifen wird manuel ein "`lock"'
benutzt. Z.B.\\object locker = new object();\\lock(locker)\{ Datenbankquery \};\\Alle
Datenbankzugriffe sind mit demselben "`lock"' gekapselt, wobei hier Vorsicht geboten ist. Es könnten
Deadlocks entstehen! 
\begin{figure}[!h]
\centering
\includegraphics[scale = 0.4]{graphics/SQLitePath.png}
\caption{SQLite Pfad}
\label{fig:abb27}
\end{figure}
\subsection{Gestaltung der Ansichten}
Beim Erstellen einer neuen Datei bietet Xamarin Studio außer
Standarddateien C\#-Dateien, wie "`Empty Class"', "`Empty Interface"' usw., noch vorgefertigte
Xamarin.Forms-Dateien, wie "`Forms ContentPage"', "`Forms ContentPage Xaml"', "`Forms Content View"'
oder "`Forms ContentView Xaml"' an. \\Wie bereits im vorherigen Kapitel erläutert, werden die
Ansichten der App in Xaml implementiert.
Der Aufbau einer Xaml-Datei ist dem Gerüst eines XML-Dokuments sehr ähnlich.
Es gibt ein Wurzelelement und jedes Element kann Attribute besitzen. Dadurch entsteht eine
übersichtliche Hierarchie der Elemente.
% Durch das Attribut x:Name könnte man auf das Element aus der Code-Behind-Datei zugreifen und bspw. den
% Text eines Labels oder die Textfarbe setzen. 
In Abb.\ref{fig:abb23} sieht man eine typische
Xaml-Datei, die eine Ansicht beschreibt und sich im Entwurf beschriebene Ordner View befindet. Diese
Ansicht wird von der benutzerdefinierten Base\_Page abgeleitet, die ihrerseits von der Klasse Xamarin.Forms.Page
abgeleitet wird.
\begin{figure}[!h]
\centering
\includegraphics[scale = 0.435]{graphics/Typische_Xaml_Datei.png}
\caption{Typische Xaml-Datei}
\label{fig:abb23}
\end{figure}
\\Eine der wichtigsten Klassenvariablen der Klasse Xamarin.Forms.Page ist das Property
\textit{BindingContext}.
Mithilfe dieser Eigenschaft wird ein Viewmodel (in diesem Fall das HeaderDataEditViewModel) an der Page-Klasse gebunden (Siehe
\ref{fig:abb23}, Zeile 23-25).
\\In Zeile 12 findet eine typische Datenbindung ("`data binding"') statt.
Das Text-Property eines Entry-Textfeldes wird an das Property \textit{Name} gebunden, das im
Viewmodel definiert wird (siehe Abb.\ref{fig:abb33}).
Sobald der Text des Textfelds sich ändert, wird das Viewmodel darüber informiert. Diese Bindung
funktioniert in beiden Richtungen, d.h. Änderungen, die im Viewmodel vorgenommen werden, werden in
der Ansicht angezeigt.\\In Abbildung \ref{fig:abb23}, Zeile 20 ist die Definition eines
Toolbarbuttons zu sehen. Sobald dieser Button gedrückt wird, wird ein Command ausgeführt, das an
das Property \textit{SaveUserDataCommand} des Viewmodels gebunden ist. D.h. dieses Klick-Event
löst den Aufruf einer Methode in der Viewmodel-Klasse auf.
\\Durch das Attribut x:Name könnte man auf das Element aus der Code-Behind-Datei zugreifen und bspw.
den Text eines Labels oder die Textfarbe setzen.\\Analog ließen sich auch die anderen Ansichten der
Scan App implementieren. Aus diesem Grund wird nicht näher ins Detail eingegangen.
\\Sollte eine
Funktionalität nicht plattformübergreifend zu realisieren sein, hat man mit Xamarin.Forms die
Möglichkeit, diese Funktionalität in den plattformspezifischen Projekten zu implementieren.
Im gemeinsamen Projekt wird ein Interface definiert, das von den dafür zuständigen Klassen in ScanApp.Droid und ScanApp.iOS implementiert
werden muss.
Der Zugriff aus dem plattformübergreifenden Projekt erfolgt folgendermaßen:\\
\textcolor{gray}{\emph{DependencyService.Get<InterfaceName>().PlattformSpecificMethodName()}}.
% \\Das Ganze veranschaulicht, welche
% Vorteile das MVVM-Architekturmuster mit sich bringt.

\begin{figure}[!h]
\centering
\includegraphics[scale = 0.6]{graphics/Bindable_Property.png}
\caption{Definition von Bindable Property}
\label{fig:abb33}
\end{figure}

\subsection{Test}
Ein wichtiger Schritt im Entwicklungszyklus einer App ist das Testen. Es wird zwischen zwei Arten
von Tests unterschieden, UI- und Unit-Tests. 
Während Unit-Tests die App-Logik testen, wird bei UI-Tests sichergestellt, dass die App so aussieht
und sich so verhält, wie man es erwartet, also es wird das Optische getestet.\\Wichtig zu beachten
ist, dass für alle Punkte aus \ref{Anforderungsanalyse} getestet werden, so dass am
Ende sichergestellt wird, dass die Anforderungen erfüllt sind. \\Ein typischer Weg, eine App zu
testen ist die Anwendung zu starten und zu benutzen.
Im besten Fall tut die App genau das was sie tun soll - funktioniert korrekt und stürzt nicht ab. Erfahrungsgemäß ist das so
gut wie nie der Fall. Diese Art von Testen, indem man die App auf einem realen Gerät nutzt, wird als UI
Acceptance Testing bezeichnet.
Die zur Verfügung gestellten Simulatoren erleichtern wesentlich den
Testprozess, allerdings um sicher zu gehen, dass eine App wirklich fehlerfrei funktioniert, kommt man an Tests auf reale Geräte nicht
herum.
\\Während der Implementierung wurde die Scan-App durchgehend auf
folgende Geräte lokal getestet:
\begin{itemize}
  \item iPhone 5 (iOS 9)
  \item iPhone 6 Plus (iOS 9.2)
  \item Samsung Galaxy S2 (Android 4.4.4 API Level 19)
  \item Samsung Galaxy S5 (Android 5.0 API Level 21)
  \item Samsung Galaxy S6 (Android 5.1.1 API Level 22)
  \item Google Nexus 7 (Android 4.4.4 API Level 19)
\end{itemize}
Da es vor allem bei Android eine große Vielfalt an Geräten gibt, kann das sehr mühsam sein.
Softwarehersteller müssen nicht selten Apps auf dutzende sogar hunderte Geräte installieren und
testen.\\Die meisten Developer verzichten auf systematisches Testen, weil die verfügbaren Tools und
Dienste zu kompliziert und schwer zu benutzen sind und nur auf einem Gerät bzw. Simulator ausgeführt
werden können. \\Abhilfe kann man sich bei einem Dienst von Xamarin, genannt Xamarin Test Cloud,
schaffen.\\Alle Xamarin-Plattform-Abonnements beinhalten 60 Xamarin Test Cloud Geräte-Minuten pro Monat. D.h. jeder Entwickler, der einen Xamarin Account hat,
kann die Dienste der Xamarin Test Cloud in Anspruch nehmen.
Xamarin verfügt über 1600 reale iOS- und Android-Smartphones und Tabletts. An dieser Stelle muss
klargestellt werden, dass es allerdings nur iOS- und Android-Geräte sind, also die Test Cloud von
Xamarin unterstützt noch nicht Windows Phone.
Mit der Test Cloud kann man leicht visuelle Inkonsistenzen feststellen, indem man die Ergebnisse eines UI-Tests auf
dutzende Geräten vergleicht. Der Entwickler hat die Möglichkeit Screenshots an beliebigen Stellen
des Tests zu machen (siehe \ref{fig:abb35}).
Darüber hinaus bietet der Service auch Videoaufnahme von Tests.
Eine Geräte-Minute wird konsumiert, wenn der Test auf einem Gerät ausgeführt wird, wobei es keine
Rolle spielt ob die Tests parallel auf mehrere Geräte oder nacheinander ausgeführt werden.\\Beim
Anlegen der Xamarin.Forms Solution, wurde außer des plattformübergreifenden Projekt und der
plattformspezifischen Projekte noch ein weiteres Projekt angelegt - das
ScanApp.UITests Projekt.
In diesem vorgefertigten Projekt befinden sich die Klassen: AppInitializer.cs und Tests.cs.\\In
AppInitializer werden Konfigurierugen vorgenommen, wie Angabe des Pfads der Android APK Datei und
der iOS IPA Datei. In der Klasse Tests.cs werden die Tests implementiert. Eine sogenannte
TestFixture umfasst mehrere Test-Methoden. Auf diese Klasse wird später näher eingegangen.
\\Xamarin.UITest
basiert auf Calabash, eins der berühmtesten Frameworks für automatisiertes Testen von mobilen Apps.
Solche Tests setzen auf den Xamarin Test Cloud Agent auf, einen speziellen HTTP-Server, der mit der
zu testenden mobilen Applikation kommuniziert.
Der Xamarin Test Cloud Agent muss eingebettet in die iOS Applikationen sein, wenn die App
kompiliert wird. Bei Android Applikationen ist der TestCloud Agent eine separate Anwendung, die
neben der zu testende App installiert wird. Die Tests interagieren mit der UI als würde ein Benutzer
in Wirklichkeit Text ein ein Entry-Feld eintippen, irgendeine Geste durchführen, oder auf einen Button klicken usw.
% Nachdem die Tests geschrieben worden sind, kann man die lokal ausführen und wenn die Tests
% erfolgreich abgeschlossen wurden, kann man die auch in der Cloud ausführen lassen.
Solche Tests können lokal ausgeführt werden und erleichtern die Entwicklung einer App. Die
eigentliche Stärke von Xamarin.UITest ist, allerdings, die Möglichkeit, diese lokale Tests in die
Xamarin Test Cloud hochzuladen. In der Cloud steht eine Vielzahl von realen Geräten (alle ohne
Jailbreak) zur Verfügung. Xamarin Test Cloud generiert bei jedem Schritt eines Testfalls Screenshots von der App.
Somit kann der Developer einen Vergleich zwischen den Darstellungen seiner App auf den verschiedenen
Geräten ziehen. Screenshots können allerdings nicht alle Benutzereindrücke abbilden. Für diesen
Zweck ist auch ein Screen Recording möglich.

Typischerweise wird jeder UITest als eine Methode definiert. Die Klasse, die den Test enthält, wird als Test Fixture bezeichnet. Eine Text Fixture enthält entweder einen Test oder eine logische Gruppe von Tests. 
Sie ist für Einstellungen und Bereingungen, die nach den Tests durchgeführt werden sollen zuständig.
Jeder Test sollte dem "`arrange-act-assert"' Muster folgen (siehe Abb. \ref{fig:abb37}):
\begin{itemize}
  \item Vereinbarungen treffen (arranging) - Vorbereitungen für den Test. D.h. hier werden
  Bedingunen eingestellt und Initialisierungen durchgeführt, so dass der Test gestartet werden kann.
  \item Handeln (acting) - Interaktionen mit der App, wie Eintippen von Text, Klicken auf Buttons
  usw.
  \item Behauptungen überprüfen (asserting) - hier werden die Ergebnisse der Interaktionen auf
  Korrektheit überprüft
\end{itemize}
\begin{figure}[!h]
\centering
\includegraphics[scale = 0.565]{graphics/XamarinUITest.png}
\caption{Xamarin.UITest}
\label{fig:abb37}
\end{figure}
Xamarin.UITests setzen auf Queries auf, um Views auf dem Screen zu lokalisieren. Diese Queries
benutzen Attributen der Views, wie Identifier, und nicht die physiche Position der Views auf dem
Screen. Dies ist eine sehr mächtige Technik, die es Xamarin.UITest erlaubt mit den Objekten zu
interagieren, unabhängig von Bildschirmgröße, Orientierung oder Layout. Xamarin.UITest bietet ein
REPL (read eval print loop) an, das sehr hilfreich beim Erstellen einer solchen Query sein kann.
REPL erlaubt Entwicklern, mit der Anwendung zu interagieren, während es läuft.
Um einen Xamarin.UITest zum laufen zu bringen, muss das NuGet Package Xamarin Test Cloud Agent zum
iOS-Projekt hinzugefügt werden. Bei Xamarin.Android ist das nicht erforderlich. Allerdings braucht
man bei Android eine APK-Datei. D.h. JDK und Android SDK müssen installiert sein. In den meisten
Fällen werden die aber mitinstalliert bei der Installation von Xamarin.Android (\cite{XamUITest}).
% \begin{figure}[!h]
% \centering
% \includegraphics[scale = 0.35]{graphics/XamarinTestCloudSucceed.png}
% \caption{Xamarin Test Cloud mit erfolgreichem Test bei allen 10 Geräten}
% \label{fig:abb39}
% \end{figure}
\begin{figure}[!h]
\centering
\includegraphics[scale = 0.15]{graphics/XamarinTestCloud.png}
\caption{Xamarin Test Cloud mit einem fehlgeschlagenen Test und 9 erfolgreich abgeschlossenen Tests}
\label{fig:abb35}
\end{figure}

