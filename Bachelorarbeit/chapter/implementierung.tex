\section{Implementierung und Test}
In diesem Abschnitt werden kurz Feststellungen beschrieben, die während der konkreten Realisierung
der Implementierung der ScanApp aufgefallen sind. Es werden noch typische Testvorgänge erläutert,
vor allem den Dienst von Xamarin - die Xamarin Test Cloud.
\\Die Benutzung von Xamarin mit Visual Studio erfordert einen Business-Account. Außerdem werden zwei
Rechner benötigt - ein Mac-Rechner als Build-Server  und ein Windows-PC auf dem Visual Studio läuft.
Aus diesem Grund fiel die Entwicklungsumgebungswahl für die Implementierung der Scan-App auf
Xamarin Studio. Xamarin Studio bietet mehrere Solution-Templates an
(siehe \ref{fig:abb36}).
\begin{figure}[!h]
\centering
\includegraphics[scale = 0.435]{graphics/XamarinStudioTemplate.png}
\caption{Xamarin Studio Solution Templates}
\label{fig:abb36}
\end{figure}
\subsection{Umsetzung des MVVM-Architekturmusters}
% Wie bereits im Kapitel \ref{MVVM} erörtert, weist das MVVM-Pattern eine lose Kopplung
% zwischen View und Viewmodel auf. Um diese Trennung visuell zu gestalten, werden drei Ordner erstellt:
% \begin{itemize}
%   \item \textbf{Model} 
%   \item \textbf{View} 
%   \item \textbf{Viewmodel} 
% \end{itemize}
Bei der Erstellung einer Xamarin.Forms
ContentPage Xaml-Datei wird automatisch auch die zugrundeliegende C\#-Datei, bekannt auch als
"`Code-Behind-Datei"', angelegt (siehe Abb. \ref{fig:abb21}).
\begin{figure}[!h]
\centering
\includegraphics[scale = 0.7]{graphics/XamlDateiPlusCSDatei.png}
\caption{Xaml-Datei und die zugrundeliegende C\#-Datei}
\label{fig:abb21}
\end{figure}
Diese Code-Behind-Datei sollte bei einer sauberen Umsetzung des MVVM-Patterns außer des Aufrufs der
\emph{InitializeComponent()} Methode im Konstruktor und eventuell Methoden, die
Viewmodelnachrichten abonnieren und die Navigation steuern, komplett leer sein.
Jede Ansicht wird an einen Viewmodel gebunden. Das wird durch das sogenannte "`Data
Binding"' (in Deutsch Datenbindung) realisiert.
% In Abb.\ref{fig:abb23} sieht man eine typische
% Xaml-Datei, die eine Ansicht beschreibt und sich im Ordner View befindet. Diese Ansicht wird
% von der benutzerdefinierten Base\_Page abgeleitet, die ihrerseits von der Klasse Xamarin.Forms.Page
% abgeleitet wird.
%  In einer C\#-Klasse, genannt Base\_Page, werden Eigenschaften und Methoden definiert, die für die
%  meisten Ansichten gemeinsam sind. Bspw. das Navigationsheader-Logo oder Methoden für die Steuerung
% der Navigation. Diese Klasse wird von der Klasse Xamarin.Forms.Page abgeleitet.
% \\Eine der wichtigsten Klassenvariablen der Klasse Xamarin.Forms.Page ist das Property
% \textit{BindingContext}.
% Mithilfe dieser Eigenschaft wird ein Viewmodel (in diesem Fall das HeaderDataEditViewModel) an der Page-Klasse gebunden (Siehe
% \ref{fig:abb23}, Zeile 23-25).
% \\In Zeile 12 findet eine typische Datenbindung ("`data binding"') statt.
% Das Text-Property eines Entry-Textfeldes wird an das Property \textit{Name} gebunden, das im
% Viewmodel definiert wird (siehe Abb.\ref{fig:abb33}).
% Sobald der Text des Textfelds sich ändert, wird das Viewmodel darüber informiert. Diese Bindung
% funktioniert in beiden Richtungen, d.h. Änderungen, die im Viewmodel vorgenommen werden, werden in
% der Ansicht angezeigt.\\In Abbildung \ref{fig:abb23}, Zeile 20 ist die Definition eines
% Toolbarbuttons zu sehen. Sobald dieser Button gedrückt wird, wird ein Command ausgeführt, das an
% das Property \textit{SaveUserDataCommand} des Viewmodels gebunden ist. D.h. dieses Klick-Event
% löst den Aufruf einer Methode in der Viewmodel-Klasse auf.\\Das Ganze veranschaulicht, welche
% Vorteile das MVVM-Architekturmuster mit sich bringt.
Durch die Datenbindung entsteht eine lose Kopplung zwischen View und ViewModel. Da das Viewmodel die
Views nicht kennt, lässt sich eine Ansicht problemlos durch eine andere austauschen. Die neue
Ansicht muss lediglich an das Viewmodel gebunden werden.
\\Ein ViewModel muss zwingend das Interface \textbf{\textit{INotifyPropertChanged}} implementieren.
Dadurch können sogenannte "`Bindable Properties"` definiert werden
%  (siehe Abb.\ref{fig:abb33})
. Bei jeder Änderung wird die OnPropertyChanged()-Methode mit dem Property-Name als String-Parameter
aufgerufen und dadurch wird ein PropertyChangedEventHandler ausgelöst.
\\Wie bei den meisten Applikationen, sind auch für die Scan-Anwendung mehrere Ansichten
erforderlich. Es stellt sich die Frage, wie wird zwischen den verschiedenen Seiten gewechselt?\\Um
zwischen den Ansichten navigieren zu können, wird eine Instanz der Klasse \textit{NavigationPage}
benötigt: \textit{new NavigationPage(new Page())}. 
\\Jede Xamarin.Forms.Page-Klasse hat über das Property \textbf{\textit{Navigation}} Zugriff auf das
NavigationPage: \textit{this.Navigation.PushAsync(new Page())}.\\Nach dem MVVM-Muster sollten sich
die Viewmodel-Klassen um die Navigation kümmern.
Allerdings ist \textit{Navigation} ein Property der Ansicht. D.h. das Viewmodel muss signalisieren,
dass es zu einer anderen Ansicht gewechselt werden soll. Da das Viewmodel die Ansicht nicht kennt,
kann das durch das \textbf{\textit{Xamarin.Forms Messaging Center}} erreicht werden. Die Ansicht
abonniert Navigationsnachrichten des Viewmodels und wird somit immer informiert, wenn die
Seite gewechselt werden soll.
\subsection{Anbindung der SQLite Datenbank}
Da beim gemeinsamen ScanApp Projekt keine Bibliotheken eingebunden werden können, muss man einen
SQLite.cs File aus Github herunterladen und in das gemeinsame Projekt (in der Model-Komponente
Persistenz, die in Abb. \ref{fig:abb41} abgebildet ist) kopieren.
Dieser C\#-File benutzt Compiler Direktiven um mehrere Plattformen in derselben Codebasis zu unterstützen.
\\Um SQLite in einer Xamarin.iOS oder Android Applikation benutzen zu können, muss man angeben, wo
der Datenbank File zu finden ist (es ist abhängig vom
Ziel-Plattform unterschiedlich). Für iOS und Android kann man "`Environment class"' benutzen um
einen validen Pfad zu konstruieren (siehe Abb. \ref{fig:abb27}). Mittels Compiler Direktiven lassen sich
spezielle Pfade für jede Plattform generieren.\\Um sicher zu gehen, dass der Code nicht versucht,
auf die SQLite Datenbank aus verschiedenen "`multiple Threads"' zuzugreifen wird manuel ein "`lock"'
benutzt. Z.B.\\object locker = new object();\\lock(locker)\{ Datenbankquery \};\\Alle
Datenbankzugriffe sind mit demselben "`lock"' gekapselt, wobei hier Vorsicht geboten ist. Es könnten
Deadlocks entstehen! 
\begin{figure}[!h]
\centering
\includegraphics[scale = 0.4]{graphics/SQLitePath.png}
\caption{SQLite Pfad}
\label{fig:abb27}
\end{figure}
\subsection{Gestaltung der Ansichten}
Beim Erstellen einer neuen Datei bietet Xamarin Studio außer
Standarddateien C\#-Dateien, wie "`Empty Class"', "`Empty Interface"' usw., noch vorgefertigte
Xamarin.Forms-Dateien, wie "`Forms ContentPage"', "`Forms ContentPage Xaml"', "`Forms Content View"'
oder "`Forms ContentView Xaml"' an. \\Wie bereits im \ref{View} erläutert, werden die
Ansichten der App in Xaml implementiert.
Der Aufbau einer Xaml-Datei ist dem Gerüst eines XML-Dokuments sehr ähnlich.
Es gibt ein Wurzelelement und jedes Element kann Attribute besitzen. Dadurch entsteht eine
übersichtliche Hierarchie der Elemente.
% Durch das Attribut x:Name könnte man auf das Element aus der Code-Behind-Datei zugreifen und bspw. den
% Text eines Labels oder die Textfarbe setzen. 
In Abb. \ref{fig:abb23} sieht man eine typische
Xaml-Datei, die die in Abb. \ref{fig:abb34} dargestellte "`Persönliche Daten Ansicht"' beschreibt und
sich in der View-Komponente (siehe Abb. \ref{fig:abb41}) befindet.
Diese Ansicht wird von der benutzerdefinierten Base\_Page abgeleitet, die ihrerseits von der Klasse Xamarin.Forms.Page
abgeleitet wird.
\begin{figure}[!h]
\centering
\includegraphics[scale = 0.435]{graphics/Typische_Xaml_Datei.png}
\caption{Typische Xaml-Datei}
\label{fig:abb23}
\end{figure}
\\Eine der wichtigsten Klassenvariablen der Klasse Xamarin.Forms.Page ist das Property
\textit{BindingContext}.
Mithilfe dieser Eigenschaft wird ein Viewmodel (in diesem Fall das HeaderDataEditViewModel) an der Page-Klasse gebunden (Siehe
\ref{fig:abb23}, Zeile 23-25).
\\In Zeile 12 findet eine typische Datenbindung ("`data binding"') statt.
Das Text-Property eines Entry-Textfeldes wird an das Property \textit{Name} gebunden, das im
Viewmodel definiert wird (siehe Abb.\ref{fig:abb33}).
Sobald der Text des Textfelds sich ändert, wird das Viewmodel darüber informiert. Diese Bindung
funktioniert in beiden Richtungen, d.h. Änderungen, die im Viewmodel vorgenommen werden, werden in
der Ansicht angezeigt.\\In Abbildung \ref{fig:abb23}, Zeile 20 ist die Definition eines
Toolbarbuttons zu sehen. Sobald dieser Button gedrückt wird, wird ein Command ausgeführt, das an
das Property \textit{SaveUserDataCommand} des Viewmodels gebunden ist. D.h. dieses Klick-Event
löst den Aufruf einer Methode in der Viewmodel-Klasse auf.
\begin{figure}[!h]
\centering
\includegraphics[scale = 0.8]{graphics/Bindable_Property.png}
\caption{Definition von Bindable Property}
\label{fig:abb33}
\end{figure}
Durch das Attribut x:Name könnte man auf das Element aus der Code-Behind-Datei zugreifen und bspw.
den Text eines Labels oder die Textfarbe setzen.\\Analog ließen sich auch die anderen Ansichten der
Scan App implementieren. Aus diesem Grund wird nicht näher ins Detail eingegangen.
% \\Das Ganze veranschaulicht, welche
% Vorteile das MVVM-Architekturmuster mit sich bringt.
\subsection{Implementierung der Navigation}
Die Implementierung der Navigation der App erfolgt ausschließlich im gemeinsamen Projekt, ScanApp.
\\In der Initialisierungsdatei der App, \emph{public class App}, wird in der Datenbank überprüft ob
bereits ein Benutzer registriert wurde. Je nachdem, ob das der Fall ist oder nicht, gibt es zwei mögliche Wege:
\begin{itemize}
  \item Im Falle, dass ein Datenbankeintrag mit einem Benutzer existiert, wird der User zu einer
  Menü-Ansicht navigiert. Diese Menü-Ansicht ist vom Typ \textbf{MasterDetailPage}. An
  dieser Stelle ist wichtig zu erwähnen, dass bei Xamarin.Adroid, die Benutzung von einer
  MasterDetailPage in einer NavigationPage nicht möglich ist und die Anwendung abstürzt. Aus
  diesem Grund wird hier folgende Compiler-Direktive zur Fallunterscheidung benutzt:
  \textcolor{gray}{
  \\ \#if \textunderscore\textunderscore iOS\textunderscore\textunderscore
   \\MainPage = new NavigationPage( new MenuMasterDetailPage());\\ \#endif}\\Für Android sieht der
   Code folgendermaßen aus:\\ \textcolor{gray}{\#if \textunderscore\textunderscore
   Android\textunderscore\textunderscore \\ MainPage = new MenuMasterDetailPage();\\ \#endif}
  \item Wenn noch kein Benutzer registriert wurde, wird eine \textbf{NavigationPage} erstellt und
  der User wird zu der \textbf{Login-Ansicht}, vom Typ ContentPage, navigiert (siehe die Mockups in
  Abb.\ref{fig:abb34}).
   Auf der Login-Ansicht gibt der User seine Kundennummer und seine
  Postleitzahl ein und die Daten werden zum Server gesendet. Im Falle einer erfolgreichen
  Registrierung, wird zu der bereits erwähnten \textbf{MasterDetailPage} navigiert (siehe Mockup
  Menüführung in Abb.\ref{fig:abb34}). Wegen der bekannten Problemen bei Xamarin.Android zwischen
  NavigationPage und MasterDetailPage, muss hier wieder unterschieden werden zwischen iOS und
  Android. Bei Android muss die Navigation von Typ "`modal"' sein (ohne Möglichkeit zurückzunavigieren).
  \\\textcolor{gray}{\#if \textunderscore\textunderscore
  Android\textunderscore\textunderscore \\this.Navigation.PushModalAsync(new MenuMasterDetailPage());\\
   \#endif}
\end{itemize} 
Es muss noch beachtet werden, dass auch wenn die Navigation "`modal"' ist, hat man bei Android
immer noch die Möglichkeit zurück zu der Login-Ansicht zu navigieren, indem man den physischen
"`Back"'-Button des Android-Geräts drückt. Das muss programmatisch deaktiviert werden und zwar nur
für Android, also "`nicht cross-plattform"'.\\Mit der bereits erwähnten Compiler-Direktive "`\#if"'
lässt sich plattformspezifisches Verhalten im gemeinsamen Code implementieren. Obwohl  hier eine
Fallunterscheidung zu beobachten ist, also kein gemeinsamer Code, erleichtert es die Wartung des
Codes. Es befindet sich in einer gemeinsamen Datei. Beim Kompilieren des Codes werden Codeabschnitte
ignoriert, wenn die nicht für das jeweilige Betriebssystem vorgesehen worden sind.\\Compiler
Direktiven kann man nicht nur um zwischen Android und iOs zu unterscheiden, sondern auch um zwischen
den verschiedenen Versionen von Android. Man kann explizit angeben, "`\textcolor{gray}{\#if
\textunderscore\textunderscore ANDROID\textunderscore21\textunderscore\textunderscore \ldots \#endif}"'
und der Code wird nur für Android API 21 kompiliert.
Auf diese Weise kann man mit Problemen umgehen, die die große Vielfalt von Android APIs mit sich
bringen.
\subsubsection{Steuerung des Menüs mit MasterDetailPage}
% In der Abb.\ref{fig:abb31} sieht man das aufgeklappte Menü der Menüsteuerungsseite der ScanApp. 
Die Xamarin.Forms.MasterDetailPage hat zwei wichtige Properties von Typ Page:
\begin{itemize}
  \item Master - eine ContentPage mit einem Element, nämlich eine TableView, in der die
  unterschiedlichen Navigationspunkte aufgelistet werden.
  \item Detail - je nachdem, welcher Navigationspunkt geklickt wurde, wird eine neue NavigationPage
  erstellt und der Benutzer wird zu der entsprechenden Ansicht (ContentPage) navigiert.
\end{itemize}
Beispielsweise sieht die Navigation zu der Kontakt-Seite folgendermaßen aus:
\\ \textcolor{gray}{\textsl{void onKontaktTapped(object sender, EventArgs e)\\ \{\\ this.Detail
= new NavigationPage(new KontaktPage());\\this.isPresent = false;
\\
\}}}
\\Die Zeile \textcolor{gray}{\textit{this.isPresent = false;}}, sorgt dafür, dass das Menü
automatisch zugeklappt wird, nachdem die ausgewählte Seite aufgemacht wurde.
\subsection{Implementierung von hardwarenahen Funktionalitäten}
Sollte eine Funktionalität nicht plattformübergreifend zu realisieren sein, hat man mit
Xamarin.Forms die Möglichkeit, diese Funktionalität in den plattformspezifischen Projekten zu implementieren.
Im gemeinsamen Projekt wird ein Interface definiert, das von den dafür zuständigen Klassen in
ScanApp.Droid und ScanApp.iOS implementiert werden muss.
% Der Zugriff aus dem plattformübergreifenden Projekt erfolgt folgendermaßen:\\
% \textcolor{gray}{\emph{DependencyService.Get<InterfaceName>().PlattformSpecificMethodName()}}.
Beispiel dafür ist die Implementierung des Scanners.
Im gemeinsamen Projekt wird das Interface IScanner.cs definiert (Abb.
\ref{fig:abb28}).
\\In beiden plattformspezifischen Projekte wird je eine Klasse Scanner.cs erstellt, die dieses
Interface implementiert(siehe Abb. \ref{fig:abb44} für die Scanner-Klasse im ScanApp.iOS und
\ref{fig:abb43} für die Android Version der Scanner-Klasse).
% Im Projekt ScanApp wird auf die plattformspezifische Scanner.cs Klassen mit:\\
% \textcolor{gray}{\emph{DependencyService.Get<IScanner>().Scan()}} zugegriffen. 
\\In Abb. \ref{fig:abb42} ist ein Ausschnitt aus der ViewModel-Klasse der Scan-Ansicht zu sehen.
Sobald auf den Scan-Button geklickt wird, wird die Scan-Methode ausgeführt. Mit dem Befehl:
\textcolor{gray}{\emph{DependencyService.Get<IScanner>().Scan()}} wird je nach Plattform die iOS-
oder die Android-Implementierung der Scan-Methode ausgeführt. In beiden Implementierungen wird der
Scanner in einem separaten Thread gestartet und wenn der Scanner fertig ist, wird die
SetScannerResult-Methode des ViewModels aufgerufen, so dass der ViewModel den weiteren Verlauf der
App steuern kann.\\Analog werden alle Fälle behandelt, wenn eine Funktionalität plattformspezifisch
implementiert werden muss. Es wird ein Interface im "`shared"' Projekt definiert. Dieses Interface
muss in den plattformspezifischen Projekten implementiert werden und mit dem Befehl:
\textcolor{gray}{\emph{DependencyService.Get<InterfaceName>()}} ruft Xamarin automatisch die
jeweilige Implementierung je nach Plattform auf.

\begin{figure}[!h]
\centering
\includegraphics[scale = 0.8]{graphics/I_Scanner.png}
\caption{Das Interface IScanner}
\label{fig:abb28}
\end{figure}
\begin{figure}[!h]
\centering
\includegraphics[scale = 0.5]{graphics/ScanViewModel.png}
\caption{Aufruf der ScanClicked-Methode aus dem ViewModel im "`shared"' Projekt}
\label{fig:abb42}
\end{figure}
\begin{figure}[!h]
\centering
\includegraphics[scale = 0.5]{graphics/Scanner_iOS.png}
\caption{iOS - plattformspezifische Implementierung der Scan-Methode}
\label{fig:abb44}
\end{figure}
\begin{figure}[!h]
\centering
\includegraphics[scale = 0.5]{graphics/Scanner_Android.png}
\caption{Android - plattformspezifische Implementierung der Scan-Methode}
\label{fig:abb43}
\end{figure}
% \begin{figure}[!h]
% \centering
% \includegraphics[scale = 0.5]{graphics/SetScanResult.png}
% \caption{Callback-Methode des ViewModels, die aus dem Scanner-Thread aufgerufen wird}
% \label{fig:abb45}
% \end{figure}
\subsection{Test}
Ein wichtiger Schritt im Entwicklungszyklus einer App ist das Testen. Es wird zwischen zwei Arten
von Tests unterschieden, UI- und Unit-Tests. 
Während Unit-Tests die App-Logik testen, wird bei UI-Tests sichergestellt, dass die App so aussieht
und sich so verhält, wie man es erwartet, also es wird das Optische getestet.\\Wichtig zu beachten
ist, dass für alle Punkte aus \ref{Anforderungsanalyse} getestet werden, so dass am
Ende sichergestellt wird, dass die Anforderungen erfüllt sind. \\Ein typischer Weg, eine App zu
testen ist die Anwendung zu starten und zu benutzen.
Im besten Fall tut die App genau das was sie tun soll - funktioniert korrekt und stürzt nicht ab. Erfahrungsgemäß ist das so
gut wie nie der Fall. Diese Art von Testen, indem man die App auf einem realen Gerät nutzt, wird als UI
Acceptance Testing bezeichnet.
Die zur Verfügung gestellten Simulatoren erleichtern wesentlich den
Testprozess, allerdings um sicher zu gehen, dass eine App wirklich fehlerfrei funktioniert, kommt man an Tests auf reale Geräte nicht
herum.
\\Während der Implementierung wurde die Scan-App durchgehend auf
folgende Geräte lokal getestet:
\begin{itemize}
  \item iPhone 5 (iOS 9)
  \item iPhone 6 Plus (iOS 9.2)
  \item Samsung Galaxy S2 (Android 4.4.4 API Level 19)
  \item Samsung Galaxy S5 (Android 5.0 API Level 21)
  \item Samsung Galaxy S6 (Android 5.1.1 API Level 22)
  \item Google Nexus 7 (Android 4.4.4 API Level 19)
\end{itemize}
Da es vor allem bei Android eine große Vielfalt an Geräten gibt, kann das sehr mühsam sein.
Softwarehersteller müssen nicht selten Apps auf dutzende sogar hunderte Geräte installieren und
testen.\\Die meisten Developer verzichten auf systematisches Testen, weil die verfügbaren Tools und
Dienste zu kompliziert und schwer zu benutzen sind und nur auf einem Gerät bzw. Simulator ausgeführt
werden können. \\Abhilfe kann man sich bei einem Dienst von Xamarin, genannt Xamarin Test Cloud,
schaffen.\\Alle Xamarin-Plattform-Abonnements beinhalten 60 Xamarin Test Cloud Geräte-Minuten pro Monat. D.h. jeder Entwickler, der einen Xamarin Account hat,
kann die Dienste der Xamarin Test Cloud in Anspruch nehmen.
Xamarin verfügt über 1600 reale iOS- und Android-Smartphones und Tabletts. An dieser Stelle muss
klargestellt werden, dass es allerdings nur iOS- und Android-Geräte sind, also die Test Cloud von
Xamarin unterstützt noch nicht Windows Phone.
Mit der Test Cloud kann man leicht visuelle Inkonsistenzen feststellen, indem man die Ergebnisse eines UI-Tests auf
dutzende Geräten vergleicht. Der Entwickler hat die Möglichkeit Screenshots an beliebigen Stellen
des Tests zu machen (siehe \ref{fig:abb35}).
Darüber hinaus bietet der Service auch Videoaufnahme von Tests.
Eine Geräte-Minute wird konsumiert, wenn der Test auf einem Gerät ausgeführt wird, wobei es keine
Rolle spielt ob die Tests parallel auf mehrere Geräte oder nacheinander ausgeführt werden.\\Beim
Anlegen der Xamarin.Forms Solution, wurde außer des plattformübergreifenden Projekt und der
plattformspezifischen Projekte noch ein weiteres Projekt angelegt - das
ScanApp.UITests Projekt.
In diesem vorgefertigten Projekt befinden sich die Klassen: AppInitializer.cs und Tests.cs.\\In
AppInitializer werden Konfigurierugen vorgenommen, wie Angabe des Pfads der Android APK Datei und
der iOS IPA Datei. In der Klasse Tests.cs werden die Tests implementiert. Eine sogenannte
TestFixture umfasst mehrere Test-Methoden. Auf diese Klasse wird später näher eingegangen.
\\Xamarin.UITest
basiert auf Calabash, eins der berühmtesten Frameworks für automatisiertes Testen von mobilen Apps.
Solche Tests setzen auf den Xamarin Test Cloud Agent auf, einen speziellen HTTP-Server, der mit der
zu testenden mobilen Applikation kommuniziert.
Der Xamarin Test Cloud Agent muss eingebettet in die iOS Applikationen sein, wenn die App
kompiliert wird. Bei Android Applikationen ist der TestCloud Agent eine separate Anwendung, die
neben der zu testende App installiert wird. Die Tests interagieren mit der UI als würde ein Benutzer
in Wirklichkeit Text ein ein Entry-Feld eintippen, irgendeine Geste durchführen, oder auf einen Button klicken usw.
% Nachdem die Tests geschrieben worden sind, kann man die lokal ausführen und wenn die Tests
% erfolgreich abgeschlossen wurden, kann man die auch in der Cloud ausführen lassen.
Solche Tests können lokal ausgeführt werden und erleichtern die Entwicklung einer App. Die
eigentliche Stärke von Xamarin.UITest ist, allerdings, die Möglichkeit, diese lokale Tests in die
Xamarin Test Cloud hochzuladen. In der Cloud steht eine Vielzahl von realen Geräten (alle ohne
Jailbreak) zur Verfügung. Xamarin Test Cloud generiert bei jedem Schritt eines Testfalls Screenshots von der App.
Somit kann der Developer einen Vergleich zwischen den Darstellungen seiner App auf den verschiedenen
Geräten ziehen. Screenshots können allerdings nicht alle Benutzereindrücke abbilden. Für diesen
Zweck ist auch ein Screen Recording möglich.

Typischerweise wird jeder UITest als eine Methode definiert. Die Klasse, die den Test enthält, wird als Test Fixture bezeichnet. Eine Text Fixture enthält entweder einen Test oder eine logische Gruppe von Tests. 
Sie ist für Einstellungen und Bereingungen, die nach den Tests durchgeführt werden sollen zuständig.
Jeder Test sollte dem "`arrange-act-assert"' Muster folgen (siehe Abb. \ref{fig:abb37}):
\begin{itemize}
  \item Vereinbarungen treffen (arranging) - Vorbereitungen für den Test. D.h. hier werden
  Bedingunen eingestellt und Initialisierungen durchgeführt, so dass der Test gestartet werden kann.
  \item Handeln (acting) - Interaktionen mit der App, wie Eintippen von Text, Klicken auf Buttons
  usw.
  \item Behauptungen überprüfen (asserting) - hier werden die Ergebnisse der Interaktionen auf
  Korrektheit überprüft
\end{itemize}
\begin{figure}[!h]
\centering
\includegraphics[scale = 0.565]{graphics/XamarinUITest.png}
\caption{Xamarin.UITest}
\label{fig:abb37}
\end{figure}
Xamarin.UITests setzen auf Queries auf, um Views auf dem Screen zu lokalisieren. Diese Queries
benutzen Attributen der Views, wie Identifier, und nicht die physiche Position der Views auf dem
Screen. Dies ist eine sehr mächtige Technik, die es Xamarin.UITest erlaubt mit den Objekten zu
interagieren, unabhängig von Bildschirmgröße, Orientierung oder Layout. Xamarin.UITest bietet ein
REPL (read eval print loop) an, das sehr hilfreich beim Erstellen einer solchen Query sein kann.
REPL erlaubt Entwicklern, mit der Anwendung zu interagieren, während es läuft.
Um einen Xamarin.UITest zum laufen zu bringen, muss das NuGet Package Xamarin Test Cloud Agent zum
iOS-Projekt hinzugefügt werden. Bei Xamarin.Android ist das nicht erforderlich. Allerdings braucht
man bei Android eine APK-Datei. D.h. JDK und Android SDK müssen installiert sein. In den meisten
Fällen werden die aber mitinstalliert bei der Installation von Xamarin.Android (\cite{XamUITest}).
% \begin{figure}[!h]
% \centering
% \includegraphics[scale = 0.35]{graphics/XamarinTestCloudSucceed.png}
% \caption{Xamarin Test Cloud mit erfolgreichem Test bei allen 10 Geräten}
% \label{fig:abb39}
% \end{figure}
\begin{figure}[!h]
\centering
\includegraphics[scale = 0.15]{graphics/XamarinTestCloud.png}
\caption{Xamarin Test Cloud mit einem fehlgeschlagenen Test und 9 erfolgreich abgeschlossenen Tests}
\label{fig:abb35}
\end{figure}

