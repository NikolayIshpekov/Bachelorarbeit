%\newpage
\section{Entwurf für die Entwicklung mit Xamarin}
In diesem Abschnitt wird der Entwurf der Scan-App mit Xamarin.Forms beschrieben. 
Es wird das für Xamarin übliche MVVM-Muster angewendet.\\Bei Xamarin.Forms gibt es zwei alternative
Methoden zum Code-Sharing:
 Shared Projects und Portable Class Libraries (PCL). Da im vorliegenden Fall Code-Sharing nur
 innerhalb der Applikation vorgesehen wurde, wird Shared Projects gewählt (der PCL
 Ansatz wird für den Fall empfohlen, wenn ein Entwickler seinen Code für andere Developer in Form
 einer DLL Bibliothek bereitstellen möchte).
Beim Erstellen des Xamarin.Forms Projekts namens ScanApp werden automatisch zwei weitere Projekte
erstellt, so dass folgende Projekte entstehen:
\begin{itemize}
  \item ScanApp - das gemeinsame, plattformübergreifende Projekt.
  \item ScanApp.Droid - plattformspezifisches Projekt für Android.
  \item ScanApp.iOS - plattformspezifisches Projekt für iOS.
\end{itemize}
Der Großteil des Codes befindet sich im plattformübergreifenden Projekt, ScanApp. In die Projekte
ScanApp.Droid und ScanApp.iOS gehören App-Ressourcen wie bspw. Icons, sowie
benutzerdefinierte Renderer. Die sogenannten "`Custom Renderer"' werden für die Implementierung und
Gestaltung von benutzerdefinierten Steuerelementen und Ansichten benötigt, die mit den von
Xamarin.Forms zur Verfügung gestellten Werkzeugen nicht zu realisieren sind. \\Sollte eine
Anforderung nicht plattformübergreifend zu gewährleisten sein, muss diese Funktionalität in den
plattformspezifischen Projekten implementiert werden. Im gemeinsamen Projekt wird ein Interface
definiert, das von den dafür zuständigen Klassen in ScanApp.Droid und ScanApp.iOS implementiert
werden muss.
% Die angeforderte Funktionalität wird in den plattformspezifischen Projekten implementiert. Dieses
% Interface muss von den jeweiligen Klassen, die die Funktionalität gewährleisten, der plattformspezifischen Projekte implementiert.
Der Zugriff aus dem plattformübergreifenden Projekt erfolgt folgendermaßen:\\
\textcolor{gray}{\emph{DependencyService.Get<InterfaceName>().PlattformSpecificMethodName()}}.
\subsection{Umsetzung des MVVM-Architekturmusters}
Wie bereits im Kapitel \ref{MVVM} erörtert, weist das MVVM-Pattern eine lose Kopplung
zwischen View und Viewmodel auf. Um diese Trennung visuell zu gestalten, werden drei Ordner erstellt:
\begin{itemize}
  \item \textbf{Model} - Im Ordner Model werden typischerweise Klassen defniert, die
  anwendungsspezifische Datentypen beschreiben. Das sind Klassen zur Speicherung und
  Verarbeitung von Daten, die dafür sorgen, dass die Daten konsistent gehalten
  werden.
  \item \textbf{View} - Alle Ansichten (Xaml-Datein, die vom Typ Xamarin.Forms.Page oder
Xamarin.Forms.View sind oder von diesen Klassen erben) gehören in den Ordner View.
  \item \textbf{Viewmodel} - In den Viewmodel-Ordner kommen die Viewmodel-Klassen (C\#-Klassen,
  die das Interface \textbf{\textit{INotifyPropertChanged}} implementieren). 
\end{itemize}
Jede Ansicht wird an ein Viewmodel gebunden. Das wird durch das sogenannte "`Data
Binding"' (in Deutsch Datenbindung) realisiert.
% In Abb.\ref{fig:abb23} sieht man eine typische
% Xaml-Datei, die eine Ansicht beschreibt und sich im Ordner View befindet. Diese Ansicht wird
% von der benutzerdefinierten Base\_Page abgeleitet, die ihrerseits von der Klasse Xamarin.Forms.Page
% abgeleitet wird.
 In einer C\#-Klasse, genannt Base\_Page, werden Eigenschaften und Methoden definiert, die für die
 meisten Ansichten gemeinsam sind. Bspw. das Navigationsheader-Logo oder Methoden für die Steuerung
der Navigation. Diese Klasse wird von der Klasse Xamarin.Forms.Page abgeleitet.
% \\Eine der wichtigsten Klassenvariablen der Klasse Xamarin.Forms.Page ist das Property
% \textit{BindingContext}.
% Mithilfe dieser Eigenschaft wird ein Viewmodel (in diesem Fall das HeaderDataEditViewModel) an der Page-Klasse gebunden (Siehe
% \ref{fig:abb23}, Zeile 23-25).
% \\In Zeile 12 findet eine typische Datenbindung ("`data binding"') statt.
% Das Text-Property eines Entry-Textfeldes wird an das Property \textit{Name} gebunden, das im
% Viewmodel definiert wird (siehe Abb.\ref{fig:abb33}).
% Sobald der Text des Textfelds sich ändert, wird das Viewmodel darüber informiert. Diese Bindung
% funktioniert in beiden Richtungen, d.h. Änderungen, die im Viewmodel vorgenommen werden, werden in
% der Ansicht angezeigt.\\In Abbildung \ref{fig:abb23}, Zeile 20 ist die Definition eines
% Toolbarbuttons zu sehen. Sobald dieser Button gedrückt wird, wird ein Command ausgeführt, das an
% das Property \textit{SaveUserDataCommand} des Viewmodels gebunden ist. D.h. dieses Klick-Event
% löst den Aufruf einer Methode in der Viewmodel-Klasse auf.\\Das Ganze veranschaulicht, welche
% Vorteile das MVVM-Architekturmuster mit sich bringt.
Durch die Datenbindung entsteht eine lose Kopplung zwischen View und ViewModel. Da das Viewmodel die
Views nicht kennt, lässt sich eine Ansicht problemlos durch eine andere austauschen. Die neue
Ansicht muss lediglich an das Viewmodel gebunden werden.
\\Ein ViewModel muss zwingend das Interface \textbf{\textit{INotifyPropertChanged}} implementieren.
Dadurch können sogenannte "`Bindable Properties"` definiert werden
%  (siehe Abb.\ref{fig:abb33})
. Bei jeder Änderung wird die OnPropertyChanged()-Methode mit dem Property-Name als String-Parameter
aufgerufen und dadurch wird ein PropertyChangedEventHandler ausgelöst.
\\Wie bei den meisten Applikationen, sind auch für die Scan-Anwendung mehrere Ansichten
erforderlich. Es stellt sich die Frage, wie wird zwischen den verschiedenen Seiten gewechselt?\\Um
zwischen den Ansichten navigieren zu können, wird eine Instanz der Klasse \textit{NavigationPage}
benötigt: \textit{new NavigationPage(new Page())}. 
\\Jede Xamarin.Forms.Page-Klasse hat über das Property \textbf{\textit{Navigation}} Zugriff auf das
NavigationPage: \textit{this.Navigation.PushAsync(new Page())}.\\Nach dem MVVM-Muster sollten sich
die Viewmodel-Klassen um die Navigation kümmern.
Allerdings ist \textit{Navigation} ein Property der Ansicht. D.h. das Viewmodel muss signalisieren,
dass es zu einer anderen Ansicht gewechselt werden soll. Da das Viewmodel die Ansicht nicht kennt,
kann das durch das \textbf{\textit{Xamarin.Forms Messaging Center}} erreicht werden. Die Ansicht
abonniert Navigationsnachrichten des Viewmodels und wird somit immer informiert, wenn die
Seite gewechselt werden soll.

% \begin{itemize}
%   \item Das Framework MVVM-Light
%   \item Messaging
%   \item unsaubere Anwendung von MVVM, wie z.B. das Property NavigatioPage einer Ansicht dem
%   zugehörigen ViewModel mitzugeben. Das würde die Navigation aus dem ViewModel ermöglichen, aber
%   es verletzt eine der Grundideen von MVVM ist es, dass der ViewModel die View nicht kennt.
% \end{itemize}


% \begin{figure}[!h]
% \centering
% \includegraphics[scale = 0.435]{graphics/Typische_Xaml_Datei.png}
% \caption{Typische Xaml-Datei}
% \label{fig:abb23}
% \end{figure}
% \begin{figure}[!h]
% \centering
% \includegraphics[scale = 0.6]{graphics/Bindable_Property.png}
% \caption{Definition von Bindable Property}
% \label{fig:abb33}
% \end{figure}
\subsection{Datenpersistenz mit SQLite}
Für die Persistenz der Appdaten wird die open-source Datenbank SQLite eingesetzt.\\SQLite ist gut
geeignet für Cross-Plattform-Entwicklung, weil:
\begin{itemize}
  \item die Datenbank klein, schnell und leicht portierbar ist;
  \item der Fileformat leicht zu benutzen und plattformübergreifend ist;
  \item SQLite die meisten SQL92 Standards implementiert.
\end{itemize}
Da
beim gemeinsamen ScanApp Projekt keine Bibliotheken eingebunden werden können, muss man einen
SQLite.cs File aus Github herunterladen und in das gemeinsame Projekt kopieren. Dieser C\#-File
benutzt Compiler Direktiven um mehrere Plattformen in derselben Codebasis zu unterstützen.
\\Um SQLite in einer Xamarin.iOS oder Android Applikation benutzen zu können, muss man angeben, wo
der Datenbank File zu finden ist (es ist abhängig vom
Ziel-Plattform unterschiedlich). Für iOs und Android kann man "`Environment class"' benutzen um einen
validen Pfad zu konstruieren (siehe Abb. \ref{fig:abb27}). Mittels Compiler Direktiven lassen sich
spezielle Pfade für jede Plattform generieren.\\Um sicher zu gehen, dass der Code nicht versucht,
auf die SQLite Datenbank aus verschiedenen "`multiple Threads"' zuzugreifen wird manuel ein "`lock"'
benutzt. Z.B.\\object locker = new object();\\lock(locker)\{ Datenbankquery \};\\Alle
Datenbankzugriffe sind mit demselben "`lock"' gekapselt, wobei hier Vorsicht geboten ist. Es könnten
Deadlocks entstehen! 
\begin{figure}[!h]
\centering
\includegraphics[scale = 0.4]{graphics/SQLitePath.png}
\caption{SQLite Pfad}
\label{fig:abb27}
\end{figure}

\subsection{GUI}
Die Benutzungsoberfläche (in English: graphical user interface (GUI)) soll den Designvorgaben der
unterschiedlichen Betriebssystemhersteller folgen. In Abb. \ref{fig:abb34} werden die Mockups für
die unterschiedelichen Ansichten der Scan-App abgebildet. 
\\Die GUI wird mit wenigen Ausnahmen im gemeinsamen Projekt, ScanApp erstellt.
Xamarin lässt Entwicklern die Wahl zwischen der Markupsprache Xaml und C\# für die Implementierung
der UIs (User Interfaces), wobei beide Techniken zum gleichen Ergebnis führen. \\Die
Positionierung der Steuerelemente und deren Funktionalität lassen sich in einer C\#-Datei
implementieren, allerdings ist der Code schwer lesbar und nicht wiederverwendbar.\\Aus diesem
Grund werden die grafischen Interfaces der ScanApp mit der Markupsprache Xaml beschrieben.
Somit wird eine strikte Trennung zwischen dem Oberflächendesign (in einer
Xaml-Datei beschrieben) und der Funktionalität (in der an der Xaml-Datei gebundenen
Viewmodel-C\#-Datei implementiert) erreicht.
Diese Technik macht Wiederverwendbarkeit und Austauschbarkeit einer Ansicht möglich.
Somit können Designer und Entwickler unabhängig voneinander arbeiten. \\Bei der Erstellung einer
Xamarin.Forms ContentPage Xaml-Datei wird automatisch auch die zugrundeliegende C\#-Datei, bekannt
auch als "`Code-Behind-Datei"', angelegt (siehe Abb. \ref{fig:abb21}).
Diese Code-Behind-Datei sollte bei einer sauberen Umsetzung des MVVM-Patterns außer des Aufrufs der
\emph{InitializeComponent()} Methode im Konstruktor und der bereits erwähnten Methoden, die
Viewmodelnachrichten abonnieren und die Navigation steuern, komplett leer sein.
Es ist möglich, dass die Funktionalität eines Viewmodels in der Code-Behind-Datei einer Ansicht
untergebracht wird. Das entspricht, allerdings, nicht dem MVVM-Architekturmuster. Dadurch
würde eine sehr enge Kopplung zwischen View und Funktionalität entstehen und die Ansichten wären
nicht mehr austauschbar. 
\begin{figure}[!h]
\centering
\includegraphics[scale = 0.7]{graphics/XamlDateiPlusCSDatei.png}
\caption{Xaml-Datei und die zugrundeliegende C\#-Datei}
\label{fig:abb21}
\end{figure}

\begin{figure}[!h]
\centering
\includegraphics[scale = 0.65]{graphics/MockUpsScanApp.png}
\caption{GUI Mockups}
\label{fig:abb34}
\end{figure}
% \\Der Aufbau einer Xaml-Datei ist dem Gerüst eines XML-Dokuments sehr ähnlich. Es gibt ein
% Wurzelelement und jedes Element kann Attribute besitzen. Dadurch entsteht eine übersichtliche Hierarchie der Elemente
% (Siehe \ref{fig:abb23}).
% Durch das Attribut x:Name könnte man auf das Element aus der Code-Behind-Datei zugreifen und bspw. den
% Text eines Labels oder die Textfarbe setzen. 
% (siehe \ref{fig:abb26}).

% \\In Abbildung \ref{fig:abb25} sieht man die zugrundeliegenden C\#-Datei, in der z.B. die
% Funktionalität der Toolbar-Buttons implementiert ist. Beim Klick auf den Button zum Speichern der
% Angaben, werden die Texten der Texteingabefeldern in einem Objekt vom Typ Kopfdaten gespeichert und
% anschließend wird das neu erstellte Objekt in die SQLite-Datenbank gespeichert. Beim Klick auf den
% Müllkorb-Button, werden die gespeicherten persönlichen Daten aus der SQLite-Datenbank gelöscht. 
% \begin{figure}[!h]
% \centering
% \includegraphics[scale = 0.7]{graphics/XamlDateiPlusCSDatei.png}
% \caption{Xaml-Datei und die zugrundeliegende C\#-Datei}
% \label{fig:abb21}
% \end{figure}
% \begin{figure}[!h]
% \centering
% \includegraphics[scale = 0.435]{graphics/Typische_Xaml_Datei.png}
% \caption{Typische Xaml-Datei}
% \label{fig:abb23}
% \end{figure}

% \begin{figure}[!h]
% \centering
% \includegraphics[scale = 0.3]{graphics/appScreenshots/PersoenlicheDaten.png}
% \caption{Screenshot: Seite zum Editieren der persönlichen Daten eines Nutzers der ScanApp}
% \label{fig:abb24}
% \end{figure}

% \begin{figure}[!h]
% \centering
% \includegraphics[scale = 0.4]{graphics/HeaderDatenCSDatei.png}
% \caption{Zugrundeliegende (Code-Behind) C\#-Datei}
% \label{fig:abb26}
% \end{figure}


% \begin{figure}[!h]
% \centering
% \includegraphics[scale = 0.5]{graphics/HeaderDatenToolbar.png}
% \caption{Zugrundeliegende C\#-Datei}
% \label{fig:abb25}
% \end{figure}

\subsection{Entwurf der Navigation zwischen den verschiedenen Seiten der ScanApp}
Die Implementierung der Navigation der App erfolgt ausschließlich im gemeinsamen Projekt, ScanApp.
\\In der Initialisierungsdatei der App, \emph{public class App}, wird in der Datenbank überprüft ob
bereits ein Benutzer registriert wurde. Je nachdem, ob das der Fall ist oder nicht, gibt es zwei mögliche Wege:
\begin{itemize}
  \item Im Falle, dass ein Datenbankeintrag mit einem Benutzer existiert, wird der User zu einer
  Menü-Ansicht navigiert. Diese Menü-Ansicht ist vom Typ \textbf{MasterDetailPage}. An
  dieser Stelle ist wichtig zu erwähnen, dass bei Xamarin.Adroid, die Benutzung von einer
  MasterDetailPage in einer NavigationPage nicht möglich ist und die Anwendung abstürzt. Aus
  diesem Grund wird hier folgende Compiler-Direktive zur Fallunterscheidung benutzt:
  \textcolor{gray}{
  \\ \#if \textunderscore\textunderscore iOS\textunderscore\textunderscore
   \\MainPage = new NavigationPage( new MenuMasterDetailPage());\\ \#endif}\\Für Android sieht der
   Code folgendermaßen aus:\\ \textcolor{gray}{\#if \textunderscore\textunderscore
   Android\textunderscore\textunderscore \\ MainPage = new MenuMasterDetailPage();\\ \#endif}
  \item Wenn noch kein Benutzer registriert wurde, wird eine \textbf{NavigationPage} erstellt und
  der User wird zu der \textbf{Login-Ansicht}, vom Typ ContentPage, navigiert (siehe die Mockups in
  Abb.\ref{fig:abb34}).
   Auf der Login-Ansicht gibt der User seine Kundennummer und seine
  Postleitzahl ein und die Daten werden zum Server gesendet. Im Falle einer erfolgreichen
  Registrierung, wird zu der bereits erwähnten \textbf{MasterDetailPage} navigiert (siehe Mockup
  Menüführung in Abb.\ref{fig:abb34}). Wegen der bekannten Problemen bei Xamarin.Android zwischen
  NavigationPage und MasterDetailPage, muss hier wieder unterschieden werden zwischen iOS und
  Android. Bei Android muss die Navigation von Typ "`modal"' sein (ohne Möglichkeit zurückzunavigieren).
  \\\textcolor{gray}{\#if \textunderscore\textunderscore
  Android\textunderscore\textunderscore \\this.Navigation.PushModalAsync(new MenuMasterDetailPage());\\
   \#endif}
\end{itemize} 
Es muss noch beachtet werden, dass auch wenn die Navigation "`modal"' ist, hat man bei Android
immernoch die Möglichkeit zurück zu der Login-Ansicht zu navigieren, indem man den physischen
"`Back"'-Button des Android-Geräts drückt. Das muss programmatisch deaktiviert werden und zwar nur
für Android, also "`nicht cross-plattform"'.
\subsubsection{Steuerung des Menüs mit MasterDetailPage}
% In der Abb.\ref{fig:abb31} sieht man das aufgeklappte Menü der Menüsteuerungsseite der ScanApp. 
Die Xamarin.Forms.MasterDetailPage hat zwei wichtige Properties von Typ Page:
\begin{itemize}
  \item Master - eine ContentPage mit einem Element, nämlich eine TableView, in der die
  unterschiedlichen Navigationspunkte aufgelistet werden.
  \item Detail - je nachdem, welcher Navigationspunkt geklickt wurde, wird eine neue NavigationPage
  erstellt und der Benutzer wird zu der entsprechenden Ansicht (ContentPage) navigiert.
\end{itemize}
Beispielsweise sieht die Navigation zu der Kontakt-Seite folgendermaßen aus:
\\ \textcolor{gray}{\textsl{void onKontaktTapped(object sender, EventArgs e)\\ \{\\ this.Detail
= new NavigationPage(new KontaktPage());\\this.isPresent = false;
\\
\}}}
\\Die Zeile \textcolor{gray}{\textit{this.isPresent = false;}}, sorgt dafür, dass das Menü
automatisch zugeklappt wird, nachdem die ausgewählte Seite aufgemacht wurde.
\subsection{Barcodescanners}
Die Implementierung des Barcodescanners ist einer der wenigen Punkten, bei denen ein Eingriff in
die plattformspezifischen Projekte notwendig ist. Sowie zum ScanApp.iOS als auch zum ScanApp.Droid
muss die Komponente ZXing.Net.Mobile hinzugefügt werden. Im gemeinsamen Projekt wird das Interface
IScanner.cs definiert (Abb. \ref{fig:abb28}). In beiden plattformspezifischen Projekte wird je eine
Klasse Scanner.cs erstellt, die dieses Interface implementiert. Im Projekt ScanApp kann
man auf die plattformspezifische Scanner.cs Klassen mit:\\
\textcolor{gray}{\emph{DependencyService.Get<IScanner>().Scan()}} zugreifen.
\begin{figure}[!h]
\centering
\includegraphics[scale = 0.4]{graphics/IScanner.png}
\caption{Das Interface IScanner}
\label{fig:abb28}
\end{figure}

\subsection{Web Services für die Kommunikation mit dem Backend}
Web Services kommen in den folgenden Fällen zum Einsatz:
\begin{itemize}
  \item Bei der einmaligen Registrierung eines Benutzers.
  \item Beim Überprüfen eines Barcodes.
  \item Beim Abschließen einer Bestellung.
  \item Beim Anzeigen des Kundennamen nach der Eingabe einer Kundennummer (Nur im
  Mitarbeiter-Modus).
\end{itemize} 
Im gemeinsamen Projekt wird für diesen Zweck eine Klasse mit jeweils eine Methode für die oben
genannten vier Fällen erstellt. Alle Methoden der Klasse benutzen den gleichen Http-Client der
Komponente \textbf{ModernHttpClient}:\\  
\textcolor{gray}{\emph{HttpClient client = new HttpClient(new
ModernHttpClient.NativeMessageHandler())}}.
\\Wie bei jeder App muss man hier beachten, dass mobile Geräte nicht selten einen schlechten oder
gar keinen Empfang haben. Abhängig vom Netzwerktyp kann die Geschwindigkeit einer Internetverbindung
stark variieren. Aus diesem Grund ist es wichtig, dass alle Serveranfragen in einem
separaten Thread ausgeführt werden, so dass der Ablauf der App nicht durch eine schlechte oder
fehlende Verbindung beeinträchtigt wird. Außerdem kann je nach Tarif der mobile Datenvolumen
begrenzt oder es können extra Kosten entstehen, wenn eine Bestimmte Grenze von verbrauchten MB pro Monat erreicht
wird. Aus diesem Grund ist es sinnvoll, dass die App in der Lage ist, den Netzwerktyp zu
erkennen. D.h. ob die Verbindung über WLAN oder über das mobile Internet erfolgt. Xamarin.Android
bietet einen Mechanismus für diesen Zweck - durch die Klasse \textbf{NetworkInfo}. Mithilfe dieser Klasse
kann die App auch erkennen ob Roaming eingeschaltet wurde (\cite{XamNetzwerkStatus}).\\Bei
Xamarin.iOS gibt es einen ähnlichen Mechanismus.
\\Der Befehl \textcolor{gray}{\textsl{Reachability.InternetConectionStatus()}} liefert Auskunft
darüber ob eine Internetverbindung über WLAN, über mobiles Internet erfolgt oder es gar keine
Verbindung besteht (\cite{XamNetzwerkStatusIOS}). Die Netzwerktyperkennung lässt sich nicht
plattformübergreifend implementieren, das erfolgt in den plattformspezifischen Projekten.
\subsection{Xamarin Komponenten (Components) und NuGet Packages}
Die Möglichkeit, Komponenten und NuGet Packages an ein Projekt anzubinden, ist eine der
größten Stärken von Xamarin.
Da bei Xamarin.Forms Shared Projects keine Komponenten zum gemeinsamen (shared) Projekt
hinzugefügt werden können, müssen die benötigten Komponenten zu den
plattformspezifischen Projekten hinzugefügt werden.
\subsubsection{Xamarin Components}
\begin{itemize}
        \item \textbf{ModernHttpClient} - Für die Kommunikation mit dem Backend wird ein Http-Client
        benötigt. Es gibt mehrere ähnliche Komponenten und NuGet Packages. \\Für die vorliegende
        Arbeit ist die Wahl auf die ModernHttpClient-Komponente gefallen, weil diese          
        vorwiegend sehr positiv in der Xamarin-Community bewertet wird und anders als andere
        ähnliche Packages auch mit dem Protokol Https funktioniert.
        \item \textbf{ZXing.Net.Mobile} - Die Kernfunktionalität der Nüßing ScanApp, nämlich die
        Scan-Funktion wird mithilfe der Xamarin-Komponente ZXing.Net.Mobile gewährleistet. Der
        Entwickler braucht sich nicht um native Funktionen, wie die Nutzung der Kamera und das Ein- und Ausschalten des
        Blitzlichtes, zu kümmern. Diese Funktionalität, sowie die Erkennung des Barcodes wird von der
        ZXing-Komponente bereitgestellt. 
\end{itemize}
\subsubsection{NuGet Packages}
\begin{itemize}
        \item \textbf{Newtonsoft.Json} - Für die Kommunikation mit dem Backend werden Json-Objekte
        benutzt.
        Damit man zu den in einem Json-Objekt enthaltenen Informationen gelangen kann, muss das Objekt
        zerteilt (geparst) werden. Das NuGet Package Newtonsoft.Json macht das Parsen eines
        Json-Objekts zu einer relativ einfache Aufgabe.
        \item \textbf{Xam.Plugin.DeviceInfo} - Beim ersten Start der Applikation, muss der Kunde sich
        einmalig registrieren. Bei der Registrierung wird auch Information über das Gerät
        mitgesendet. Zu dieser nativen Information gelangt man mithilfe des NuGet Packages,
        Xam.Plugin.DeviceInfo.
\end{itemize}
Es gibt eine große Vielfalt an Xamarin Komponenten und NuGet Packages. Somit kann eine
Xamarin Applikation mit mehreren Features angereichert werden. 