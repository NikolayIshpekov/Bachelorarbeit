\section{Entwurf für die Entwicklung mit Xamarin}
In diesem Abschnitt wird der Entwurf der Scan-App mit Xamarin.Forms beschrieben. 
Es wird das für Xamarin.Forms übliche MVVM-Muster angewendet.\\Bei Xamarin.Forms gibt es zwei
alternative Methoden zum Code-Sharing:
 Shared Projects und Portable Class Libraries (PCL). Da im vorliegenden Fall Code-Sharing nur
 innerhalb der Applikation vorgesehen wurde, wird Shared Projects gewählt (der PCL
 Ansatz wird für den Fall empfohlen, wenn ein Entwickler seinen Code für andere Developer in Form
 einer DLL Bibliothek bereitstellen möchte).
 Der Sinn von Xamarin.Forms ist es, dass man mit einer gemeinsamen Codebasis, mehrere Versionen
 einer App erstellen kann (im vorliegenden Fall sind es iOS- und Android-Version der Anwendung.
 Mit einem Xamarin Business Account wäre auch eine Windows Phone-Version möglich).
 Beim Anlegen des Xamarin.Forms Projekts namens ScanApp werden automatisch zwei weitere Projekte erstellt, so dass folgende Projekte entstehen:
\begin{itemize}
  \item ScanApp - das gemeinsame, plattformübergreifende Projekt.
  \item ScanApp.Droid - plattformspezifisches Projekt für Android.
  \item ScanApp.iOS - plattformspezifisches Projekt für iOS.
\end{itemize}
Abb. \ref{fig:abb40} veranschaulicht die Verteilung der Projekten.
Der Großteil des Codes wird sich im plattformübergreifenden Projekt, ScanApp befinden. In diesem
"`shared"' Projekt wird typischerweise die gesamte App-Logik, inklusive Gestaltung der
Benutzungsoberfläche, ausgelagert. Xamarin.Forms ist eine Art Abstraktionsschicht, mit derer Hilfe
sich die Benutzungsoberfläche in diesem gemeinsamen, plattformübergreifenden Projekt gestalten
lässt.
D.h. die Ansichten werden komplett plattformunabhängig definiert. 
Beim Kompilieren werden die Xamarin.Forms Steuerelemente je nach Plattform in
das native Pendant (ListView bei Android und UITableView bei iOS) übersetzt.\\In die Projekte
ScanApp.Droid und ScanApp.iOS gehören App-Ressourcen wie bspw.
Icons, sowie eventuell benutzerdefinierte Renderer. Die sogenannten "`Custom Renderer"' werden für
die Implementierung von benutzerdefinierten Steuerelementen und Ansichten benötigt, die mit den von
Xamarin.Forms zur Verfügung gestellten Werkzeugen nicht zu realisieren sind. Allerdings
muss es angemerkt werden, dass die von Xamarin.Forms angebotenen Steuerelemente meistens
ausreichend sind, so dass ein benutzerdefinierter Renderer selten benötigt wird. Ein Beispiel
wäre die Hintergrundfarbe einer markierten Zeile eines ListViews. Sie ist bspw. blau bei Android und
grau bei der iOS Version einer mit Xamarin.Forms erstellter App.
Obwohl die Ansichten im "`shared"' Projekt erstellt worden sind, sehen sie auf den Zielplattformen
nicht gleich aus. Grund dafür ist die Tatsache, dass der gemeinsame Code aus dem "`shared"' Projekt
zum nativen Code kompiliert wird. D.h. es entstehen native Steuerelemente, die spezifische Merkmale
der jeweiligen Plattform tragen.
Sollte die Hintergrundfarbe bei Android auch grau sein, wäre ein Custom Renderer im
plattformspezifischen Droid-Projekt nötig. D.h. das native Android-Steuerelement soll überschrieben
werden.\\Außer als Container für benutzerdefinierte Renderer und App-Ressourcen, werden in den
plattformspezifischen Projekte noch Einstellungen vorgenommen, wie Info.plist im iOS-Projekt oder
AndroidManifest.xml bei Android. 
Wie aus Abb. \ref{fig:abb40} ersichtlich, lassen sich beim "`Shared Projects"'-Ansatz keine "`open
source"' Bibliotheken, wie NuGet Packages oder Xamarin Komponenten direkt an das gemeinsame Projekt anbinden.
Das erfolgt in den plattformspezifischen Projekte. Darüber hinaus lassen sich zwei Arten von "`open
source"' Eine solche Xamarin Komponente ist bspw. die ZXing-Komponente zum Scannen von Barcodes, die
eine zentrale Rolle in der App spielt. Das ebenso in der ScanApp eingebundene NuGet Package
"`DeviceInfo"' bietet eine API, mit der Entwickler Informationen über das Smartphone bekommen
können. Am Ende dieses Kapitels werden die für die ScanApp benötigten NuGut Packages und Xamarin
Komponenten näher vorgestellt. 
% \\Der Entwurf der ScanApp bezieht sich fast ausschließlich auf das
% "`shared"' Projekt (siehe Abb. \ref{fig:abb40}). 
\\Wie bereits angesprochen, ist der Sinn von
"`Cross-Plattform-Entwicklung"', dass alles, was sich auslagern lässt, in das gemeinsame Projekt
gehört. Die plattformspezifischen Projekte sollten möglichst "`leer"' bleiben.
Im Folgenden wird einen Einblick in die Strukturen der drei Projekte gegeben, beginnend beim
"`shared"' ScanApp Projekt (siehe Abb. \ref{fig:abb41}).
\begin{figure}[!h]
\centering
\includegraphics[scale = 0.7]{graphics/ScanAppProjekt.png}
\caption{ScanApp - Entwurf}
\label{fig:abb40}
\end{figure}
\begin{figure}[!h]
\centering
\includegraphics[scale = 0.46]{graphics/SharedScanApp.png}
\caption{ScanApp - Entwurf (Shared Projekt)}
\label{fig:abb41}
\end{figure}
% \\Sollte eine
% Anforderung nicht plattformübergreifend zu gewährleisten sein, muss diese Funktionalität in den
% plattformspezifischen Projekten implementiert werden. Im gemeinsamen Projekt wird ein Interface
% definiert, das von den dafür zuständigen Klassen in ScanApp.Droid und ScanApp.iOS implementiert
% werden muss.
% Die angeforderte Funktionalität wird in den plattformspezifischen Projekten implementiert. Dieses
% Interface muss von den jeweiligen Klassen, die die Funktionalität gewährleisten, der plattformspezifischen Projekte implementiert.
% Der Zugriff aus dem plattformübergreifenden Projekt erfolgt folgendermaßen:\\
% \textcolor{gray}{\emph{DependencyService.Get<InterfaceName>().PlattformSpecificMethodName()}}.
% \subsection{Umsetzung des MVVM-Architekturmusters}
% Wie bereits im Kapitel \ref{MVVM} erörtert, weist das MVVM-Pattern eine lose Kopplung
% zwischen View und Viewmodel auf. Um diese Trennung visuell zu gestalten, werden drei Ordner erstellt:
% \begin{itemize}
%   \item \textbf{Model} - Im Ordner Model werden typischerweise Klassen defniert, die
%   anwendungsspezifische Datentypen beschreiben. Das sind Klassen zur Speicherung und
%   Verarbeitung von Daten, die dafür sorgen, dass die Daten konsistent gehalten
%   werden.
%   \item \textbf{View} - Alle Ansichten (Xaml-Datein, die vom Typ Xamarin.Forms.Page oder
% Xamarin.Forms.View sind oder von diesen Klassen erben) gehören in den Ordner View.
%   \item \textbf{Viewmodel} - In den Viewmodel-Ordner kommen die Viewmodel-Klassen (C\#-Klassen,
%   die das Interface \textbf{\textit{INotifyPropertChanged}} implementieren). 
% \end{itemize}
% Jede Ansicht wird an ein Viewmodel gebunden. Das wird durch das sogenannte "`Data
% Binding"' (in Deutsch Datenbindung) realisiert.
% % In Abb.\ref{fig:abb23} sieht man eine typische
% % Xaml-Datei, die eine Ansicht beschreibt und sich im Ordner View befindet. Diese Ansicht wird
% % von der benutzerdefinierten Base\_Page abgeleitet, die ihrerseits von der Klasse Xamarin.Forms.Page
% % abgeleitet wird.
%  In einer C\#-Klasse, genannt Base\_Page, werden Eigenschaften und Methoden definiert, die für die
%  meisten Ansichten gemeinsam sind. Bspw. das Navigationsheader-Logo oder Methoden für die Steuerung
% der Navigation. Diese Klasse wird von der Klasse Xamarin.Forms.Page abgeleitet.
% % \\Eine der wichtigsten Klassenvariablen der Klasse Xamarin.Forms.Page ist das Property
% % \textit{BindingContext}.
% % Mithilfe dieser Eigenschaft wird ein Viewmodel (in diesem Fall das HeaderDataEditViewModel) an der Page-Klasse gebunden (Siehe
% % \ref{fig:abb23}, Zeile 23-25).
% % \\In Zeile 12 findet eine typische Datenbindung ("`data binding"') statt.
% % Das Text-Property eines Entry-Textfeldes wird an das Property \textit{Name} gebunden, das im
% % Viewmodel definiert wird (siehe Abb.\ref{fig:abb33}).
% % Sobald der Text des Textfelds sich ändert, wird das Viewmodel darüber informiert. Diese Bindung
% % funktioniert in beiden Richtungen, d.h. Änderungen, die im Viewmodel vorgenommen werden, werden in
% % der Ansicht angezeigt.\\In Abbildung \ref{fig:abb23}, Zeile 20 ist die Definition eines
% % Toolbarbuttons zu sehen. Sobald dieser Button gedrückt wird, wird ein Command ausgeführt, das an
% % das Property \textit{SaveUserDataCommand} des Viewmodels gebunden ist. D.h. dieses Klick-Event
% % löst den Aufruf einer Methode in der Viewmodel-Klasse auf.\\Das Ganze veranschaulicht, welche
% % Vorteile das MVVM-Architekturmuster mit sich bringt.
% Durch die Datenbindung entsteht eine lose Kopplung zwischen View und ViewModel. Da das Viewmodel die
% Views nicht kennt, lässt sich eine Ansicht problemlos durch eine andere austauschen. Die neue
% Ansicht muss lediglich an das Viewmodel gebunden werden.
% \\Ein ViewModel muss zwingend das Interface \textbf{\textit{INotifyPropertChanged}} implementieren.
% Dadurch können sogenannte "`Bindable Properties"` definiert werden
% %  (siehe Abb.\ref{fig:abb33})
% . Bei jeder Änderung wird die OnPropertyChanged()-Methode mit dem Property-Name als String-Parameter
% aufgerufen und dadurch wird ein PropertyChangedEventHandler ausgelöst.
% \\Wie bei den meisten Applikationen, sind auch für die Scan-Anwendung mehrere Ansichten
% erforderlich. Es stellt sich die Frage, wie wird zwischen den verschiedenen Seiten gewechselt?\\Um
% zwischen den Ansichten navigieren zu können, wird eine Instanz der Klasse \textit{NavigationPage}
% benötigt: \textit{new NavigationPage(new Page())}. 
% \\Jede Xamarin.Forms.Page-Klasse hat über das Property \textbf{\textit{Navigation}} Zugriff auf das
% NavigationPage: \textit{this.Navigation.PushAsync(new Page())}.\\Nach dem MVVM-Muster sollten sich
% die Viewmodel-Klassen um die Navigation kümmern.
% Allerdings ist \textit{Navigation} ein Property der Ansicht. D.h. das Viewmodel muss signalisieren,
% dass es zu einer anderen Ansicht gewechselt werden soll. Da das Viewmodel die Ansicht nicht kennt,
% kann das durch das \textbf{\textit{Xamarin.Forms Messaging Center}} erreicht werden. Die Ansicht
% abonniert Navigationsnachrichten des Viewmodels und wird somit immer informiert, wenn die
% Seite gewechselt werden soll.

% \begin{itemize}
%   \item Das Framework MVVM-Light
%   \item Messaging
%   \item unsaubere Anwendung von MVVM, wie z.B. das Property NavigatioPage einer Ansicht dem
%   zugehörigen ViewModel mitzugeben. Das würde die Navigation aus dem ViewModel ermöglichen, aber
%   es verletzt eine der Grundideen von MVVM ist es, dass der ViewModel die View nicht kennt.
% \end{itemize}


% \begin{figure}[!h]
% \centering
% \includegraphics[scale = 0.435]{graphics/Typische_Xaml_Datei.png}
% \caption{Typische Xaml-Datei}
% \label{fig:abb23}
% \end{figure}
% \begin{figure}[!h]
% \centering
% \includegraphics[scale = 0.6]{graphics/Bindable_Property.png}
% \caption{Definition von Bindable Property}
% \label{fig:abb33}
% \end{figure}
\subsection{Datenpersistenz und Backend-Kommunikation}
Fast jede mobile Anwendung braucht einen Mechanismus, der eine dauerhafte lokale Speicherung der
Appdaten erlaubt. Das gilt besonders für die Kategorie der Business Apps, zu der die zu entwickelnde
ScanApp auch zählt.Typischerweise wird für diesen Zweck eine leichtgewichtige Datenbank, namens
SQLite benutzt.
Die "`open-source"' Datenbank SQLite ist gut geeignet für das Persistieren von Daten bei mobilen
Applikationen, weil:
\begin{itemize}
  \item die Datenbank klein, schnell und leicht portierbar ist;
  \item der Fileformat leicht zu benutzen und plattformübergreifend ist;
  \item SQLite die meisten SQL92 Standards implementiert.
\end{itemize}
Darüber hinaus ist SQLite die Standardlösung bei der nativen Android-App-Entwicklung und sehr
verbreitet bei der iOS-App-Entwicklung.
Xamarin.Forms unterstützt die Anbindung von SQLite und zwar cross-plattform. In den plattformspezifischen Projekte
muss lediglich jeweils eine SQLite-Datei zu den Ressourcen hinzugefügt werden. Im gemeinsamen
Projekt müssen die Pfade zu den jeweiligen SQL-Datenbanken angegeben werden, einmal für Android und
einmal für iOS. Die Zugriffe auf die Datenbank erfolgen plattformübergreifend.

Ein weiterer wichtiger und häufig vorkommender Punkt bei der Entwicklung von Apps, ist die
Kommunikation mit dem Backend. Ähnlich wie die Anforderung für dauerhafte lokale Speicherung der App
Daten, müssen viele Apps (vor allem Business Apps) mit einem Server über das Internet kommunizieren.
Diese Kommunikation erfolgt über sogenannte Web Services.
\\Stellvertretend für die meisten Apps dieser Kategorie, kommt es bei der ScanApp in den
folgenden Fällen zum Einsatz von Web Services:
\begin{itemize}
  \item Bei der einmaligen Registrierung eines Benutzers.
  \item Beim Überprüfen eines Barcodes.
  \item Beim Abschließen einer Bestellung.
\end{itemize} 
Das sind drei typische Interaktionen zwischen App und Backend. Im Prinzip ist es belanglos,
wofür konkret Web Services eingesetzt werden, weil die immer nach dem gleichen Muster funktionieren.
Die App sendet eine Anfrage, im vorliegenden Fall in Form eines Json-Objekts (oft werden auch XML-Dateien zwischen App
und Server ausgetauscht, wobei bei XML der Overhead größer ist) und der Server antwortet
mit einer Datei desselben Formats. Damit die Kommunikation gelingt, müssen sich Server und Client an
einem Vertrag halten. In diesem Vertrag wird die Struktur des Json-Objekts definiert. D.h.
die App muss in der Lage sein, dieses Objekt zu parsen, um die Antwort vom Server verstehen zu
können. Für das Parsen eines Json-Objekts wird das NuGet Package \textbf{Newtonsoft.Json} in 
die Projekte ScanApp.iOS und ScanApp.Droid eingebunden. Die Kommunikation erfolgt mit dem
Http-Client der Xamarin Komponente \textbf{ModernHttpClient}, die ebenso in die
plattformspezifischen Projekte eingebunden werden muss.\\Die Implementierung ist
plattformübergreifend, im gemeinsamen Projekt wird eine Klasse (siehe Abb. \ref{fig:abb41}, die
Klassse HttpBackend) mit jeweils eine Methode für die oben genannten drei Fällen erstellt.
% \\  
% \textcolor{gray}{\emph{HttpClient client = new HttpClient(new
% ModernHttpClient.NativeMessageHandler())}}.
\\Wie bei jeder App muss man hier beachten, dass mobile Geräte nicht selten einen schlechten oder
gar keinen Empfang haben. Abhängig vom Netzwerktyp kann die Geschwindigkeit einer Internetverbindung
stark variieren. Aus diesem Grund ist es wichtig, dass alle Serveranfragen in einem
separaten Thread ausgeführt werden, so dass der Ablauf der App nicht durch eine schlechte oder
fehlende Verbindung beeinträchtigt wird. Außerdem kann je nach Tarif der mobile Datenvolumen
begrenzt oder es können extra Kosten entstehen, wenn eine Bestimmte Grenze von verbrauchten MB pro Monat erreicht
wird. Aus diesem Grund ist es sinnvoll, dass die App in der Lage ist, den Netzwerktyp zu
erkennen. D.h. ob die Verbindung über WLAN oder über das mobile Internet erfolgt. Xamarin.Android
bietet einen Mechanismus für diesen Zweck - durch die Klasse \textbf{NetworkInfo}. Mithilfe dieser Klasse
kann die App auch erkennen ob Roaming eingeschaltet wurde (\cite{XamNetzwerkStatus}).\\Bei
Xamarin.iOS gibt es einen ähnlichen Mechanismus.
\\Der Befehl \textcolor{gray}{\textsl{Reachability.InternetConectionStatus()}} liefert Auskunft
darüber ob eine Internetverbindung über WLAN, über mobiles Internet erfolgt oder es gar keine
Verbindung besteht (\cite{XamNetzwerkStatusIOS}). \\Die Netzwerktyperkennung lässt sich nicht
plattformübergreifend implementieren, das erfolgt in den plattformspezifischen Projekten. Im Sinne von "`Cross-Plattform-Entwicklung"' wird für solche Fälle ein Interface im gemeinsamen Projekt definiert. Dieses Interface wird dann in den plattformspezifischen Projekten implementiert. Auf
diese Weise lässt sich die Netzwerktyperkennung aus dem "`shared"' Projekt steuern und
dementsprechend behandeln. Da bei der ScanApp eine Übertragung von
größeren Dateien, wie bspw. Bilder nicht vorgesehen ist, ist eine Netzwerktyperkennung unnötig und
es wurde darauf verzichtet.
% Da beim gemeinsamen ScanApp Projekt keine Bibliotheken eingebunden werden können, muss man einen
% SQLite.cs File aus Github herunterladen und in das gemeinsame Projekt kopieren. Dieser C\#-File
% benutzt Compiler Direktiven um mehrere Plattformen in derselben Codebasis zu unterstützen.
% \\Um SQLite in einer Xamarin.iOS oder Android Applikation benutzen zu können, muss man angeben, wo
% der Datenbank File zu finden ist (es ist abhängig vom
% Ziel-Plattform unterschiedlich). Für iOs und Android kann man "`Environment class"' benutzen um einen
% validen Pfad zu konstruieren (siehe Abb. \ref{fig:abb27}). Mittels Compiler Direktiven lassen sich
% spezielle Pfade für jede Plattform generieren.\\Um sicher zu gehen, dass der Code nicht versucht,
% auf die SQLite Datenbank aus verschiedenen "`multiple Threads"' zuzugreifen wird manuel ein "`lock"'
% benutzt. Z.B.\\object locker = new object();\\lock(locker)\{ Datenbankquery \};\\Alle
% Datenbankzugriffe sind mit demselben "`lock"' gekapselt, wobei hier Vorsicht geboten ist. Es könnten
% Deadlocks entstehen! 
% \begin{figure}[!h]
% \centering
% \includegraphics[scale = 0.4]{graphics/SQLitePath.png}
% \caption{SQLite Pfad}
% \label{fig:abb27}
% \end{figure}
\subsection{Model}
\subsection{View}
\subsection{ViewModel}
\subsection{Util}

\subsection{GUI}
Die Benutzungsoberfläche (in English: graphical user interface (GUI)) soll den Designvorgaben der
unterschiedlichen Betriebssystemhersteller folgen. Der Entwickler soll sich, allerdings, nicht darum
kümmern, diese Aufgabe erledigt Xamarin. Der Xamarin-Code wird pro Plattform zu Maschinencode
kompiliert und dadurch erweckt die App den Eindruck, Teil der konkreten Plattform zu sein. D.h.
aus der Perspektive eines Benutzers fühlt sich eine Xamarin.iOS App wie jede native iOS App an.
Selbstverständlich gilt dasselbe für eine Xamarin.Android App. \\In Abb.
\ref{fig:abb34} werden die Mockups für die unterschiedelichen Ansichten der Scan-App abgebildet. 
\\Die GUI wird mit wenigen Ausnahmen im gemeinsamen Projekt, ScanApp erstellt.
Xamarin lässt Entwicklern die Wahl zwischen der Markupsprache Xaml und C\# für die Implementierung
der UIs (User Interfaces), wobei beide Techniken zum gleichen Ergebnis führen. \\Die
Positionierung der Steuerelemente und deren Funktionalität lassen sich in einer C\#-Datei
implementieren, allerdings ist der Code schwer lesbar und nicht wiederverwendbar.\\Aus diesem
Grund werden die grafischen Interfaces der Scan-App mit der Markupsprache Xaml beschrieben.
Somit wird eine strikte Trennung zwischen dem Oberflächendesign (in einer
Xaml-Datei beschrieben) und der Funktionalität (in der an der Xaml-Datei gebundenen
Viewmodel-C\#-Datei implementiert) erreicht.
Diese Technik macht Wiederverwendbarkeit und Austauschbarkeit einer Ansicht möglich und Designer und
Entwickler können unabhängig voneinander arbeiten. \\Bei der Erstellung einer Xamarin.Forms
ContentPage Xaml-Datei wird automatisch auch die zugrundeliegende C\#-Datei, bekannt auch als "`Code-Behind-Datei"', angelegt (siehe Abb. \ref{fig:abb21}).
Diese Code-Behind-Datei sollte bei einer sauberen Umsetzung des MVVM-Patterns außer des Aufrufs der
\emph{InitializeComponent()} Methode im Konstruktor und der bereits erwähnten Methoden, die
Viewmodelnachrichten abonnieren und die Navigation steuern, komplett leer sein.
Es ist möglich, dass die Funktionalität eines Viewmodels in der Code-Behind-Datei einer Ansicht
untergebracht wird. Das entspricht, allerdings, nicht dem MVVM-Architekturmuster. Dadurch
würde eine sehr enge Kopplung zwischen View und Funktionalität entstehen und die Ansichten wären
nicht mehr austauschbar.\\Durch Xamarin.Forms kann man die ganze Benutzungsoberfläche im gemeinsamen
Projekt implementieren. D.h. jede Erweiterung oder Änderung einer Ansicht kann zentral, an einer
Stelle, durchgeführt werden. Sollte man zu einem späteren Zeitpunkt Design-Änderungen vornehmen
möchten, müsste man es dann nur einmal implementieren.\\Da der gemeinsame Code zu nativem
Maschinencode kompiliert wird und die Steuerelemente die gleiche Funktionalität haben, sieht die
Android-Benutzungsoberfläche nicht unbedingt gleich wie die von iOS oder eventuell die von Windows
Phone aus.\\Ein Eingriff in die plattformspezifischen Projekte, ist nur in den Fällen notwendig,
wenn die von Xamarin.Forms angebotenen Steuerelemente sich nicht so verhalten wie der Entwickler bzw. der Designer der App es sich vorstellt. Dann werden sogenannte
"`Custom Renderer"' Klassen in die plattformspezifischen Projekten benötigt. In denen kann man
Änderungen vornehmen, wie z.B. das Definieren von runden Buttons. \\Die Layouts der  mit
Xamarin.Forms erstellten Ansichten passen sich dynamisch an die Größe des Bildschirms an.
Bei den vielen verschiedenen Geräten ist das eine wesentliche Erleichterung für den Entwickler. 
\begin{figure}[!h]
\centering
\includegraphics[scale = 0.7]{graphics/XamlDateiPlusCSDatei.png}
\caption{Xaml-Datei und die zugrundeliegende C\#-Datei}
\label{fig:abb21}
\end{figure}

\begin{figure}[!h]
\centering
\includegraphics[scale = 0.65]{graphics/MockUpsScanApp.png}
\caption{GUI Mockups}
\label{fig:abb34}
\end{figure}
% \\Der Aufbau einer Xaml-Datei ist dem Gerüst eines XML-Dokuments sehr ähnlich. Es gibt ein
% Wurzelelement und jedes Element kann Attribute besitzen. Dadurch entsteht eine übersichtliche Hierarchie der Elemente
% (Siehe \ref{fig:abb23}).
% Durch das Attribut x:Name könnte man auf das Element aus der Code-Behind-Datei zugreifen und bspw. den
% Text eines Labels oder die Textfarbe setzen. 
% (siehe \ref{fig:abb26}).

% \\In Abbildung \ref{fig:abb25} sieht man die zugrundeliegenden C\#-Datei, in der z.B. die
% Funktionalität der Toolbar-Buttons implementiert ist. Beim Klick auf den Button zum Speichern der
% Angaben, werden die Texten der Texteingabefeldern in einem Objekt vom Typ Kopfdaten gespeichert und
% anschließend wird das neu erstellte Objekt in die SQLite-Datenbank gespeichert. Beim Klick auf den
% Müllkorb-Button, werden die gespeicherten persönlichen Daten aus der SQLite-Datenbank gelöscht. 
% \begin{figure}[!h]
% \centering
% \includegraphics[scale = 0.7]{graphics/XamlDateiPlusCSDatei.png}
% \caption{Xaml-Datei und die zugrundeliegende C\#-Datei}
% \label{fig:abb21}
% \end{figure}
% \begin{figure}[!h]
% \centering
% \includegraphics[scale = 0.435]{graphics/Typische_Xaml_Datei.png}
% \caption{Typische Xaml-Datei}
% \label{fig:abb23}
% \end{figure}

% \begin{figure}[!h]
% \centering
% \includegraphics[scale = 0.3]{graphics/appScreenshots/PersoenlicheDaten.png}
% \caption{Screenshot: Seite zum Editieren der persönlichen Daten eines Nutzers der ScanApp}
% \label{fig:abb24}
% \end{figure}

% \begin{figure}[!h]
% \centering
% \includegraphics[scale = 0.4]{graphics/HeaderDatenCSDatei.png}
% \caption{Zugrundeliegende (Code-Behind) C\#-Datei}
% \label{fig:abb26}
% \end{figure}


% \begin{figure}[!h]
% \centering
% \includegraphics[scale = 0.5]{graphics/HeaderDatenToolbar.png}
% \caption{Zugrundeliegende C\#-Datei}
% \label{fig:abb25}
% \end{figure}

\subsection{Entwurf der Navigation zwischen den verschiedenen Seiten der ScanApp}
Die Implementierung der Navigation der App erfolgt ausschließlich im gemeinsamen Projekt, ScanApp.
\\In der Initialisierungsdatei der App, \emph{public class App}, wird in der Datenbank überprüft ob
bereits ein Benutzer registriert wurde. Je nachdem, ob das der Fall ist oder nicht, gibt es zwei mögliche Wege:
\begin{itemize}
  \item Im Falle, dass ein Datenbankeintrag mit einem Benutzer existiert, wird der User zu einer
  Menü-Ansicht navigiert. Diese Menü-Ansicht ist vom Typ \textbf{MasterDetailPage}. An
  dieser Stelle ist wichtig zu erwähnen, dass bei Xamarin.Adroid, die Benutzung von einer
  MasterDetailPage in einer NavigationPage nicht möglich ist und die Anwendung abstürzt. Aus
  diesem Grund wird hier folgende Compiler-Direktive zur Fallunterscheidung benutzt:
  \textcolor{gray}{
  \\ \#if \textunderscore\textunderscore iOS\textunderscore\textunderscore
   \\MainPage = new NavigationPage( new MenuMasterDetailPage());\\ \#endif}\\Für Android sieht der
   Code folgendermaßen aus:\\ \textcolor{gray}{\#if \textunderscore\textunderscore
   Android\textunderscore\textunderscore \\ MainPage = new MenuMasterDetailPage();\\ \#endif}
  \item Wenn noch kein Benutzer registriert wurde, wird eine \textbf{NavigationPage} erstellt und
  der User wird zu der \textbf{Login-Ansicht}, vom Typ ContentPage, navigiert (siehe die Mockups in
  Abb.\ref{fig:abb34}).
   Auf der Login-Ansicht gibt der User seine Kundennummer und seine
  Postleitzahl ein und die Daten werden zum Server gesendet. Im Falle einer erfolgreichen
  Registrierung, wird zu der bereits erwähnten \textbf{MasterDetailPage} navigiert (siehe Mockup
  Menüführung in Abb.\ref{fig:abb34}). Wegen der bekannten Problemen bei Xamarin.Android zwischen
  NavigationPage und MasterDetailPage, muss hier wieder unterschieden werden zwischen iOS und
  Android. Bei Android muss die Navigation von Typ "`modal"' sein (ohne Möglichkeit zurückzunavigieren).
  \\\textcolor{gray}{\#if \textunderscore\textunderscore
  Android\textunderscore\textunderscore \\this.Navigation.PushModalAsync(new MenuMasterDetailPage());\\
   \#endif}
\end{itemize} 
Es muss noch beachtet werden, dass auch wenn die Navigation "`modal"' ist, hat man bei Android
immer noch die Möglichkeit zurück zu der Login-Ansicht zu navigieren, indem man den physischen
"`Back"'-Button des Android-Geräts drückt. Das muss programmatisch deaktiviert werden und zwar nur
für Android, also "`nicht cross-plattform"'.\\Mit der bereits erwähnten Compiler-Direktive "`\#if"'
lässt sich plattformspezifisches Verhalten im gemeinsamen Code implementieren. Obwohl  hier eine
Fallunterscheidung zu beobachten ist, also kein gemeinsamer Code, erleichtert es die Wartung des
Codes. Es befindet sich in einer gemeinsamen Datei. Beim Kompilieren des Codes werden Codeabschnitte
ignoriert, wenn die nicht für das jeweilige Betriebssystem vorgesehen worden sind.\\Compiler
Direktiven kann man nicht nur um zwischen Android und iOs zu unterscheiden, sondern auch um zwischen
den verschiedenen Versionen von Android. Man kann explizit angeben, "`\textcolor{gray}{\#if
\textunderscore\textunderscore ANDROID\textunderscore21\textunderscore\textunderscore \ldots \#endif}"'
und der Code wird nur für Android API 21 kompiliert.
Auf diese Weise kann man mit Problemen umgehen, die die große Vielfalt von Android APIs mit sich
bringen.
\subsubsection{Steuerung des Menüs mit MasterDetailPage}
\begin{figure}[!h]
\centering
\includegraphics[scale = 0.7]{graphics/ScanApp_Navigation.png}
\caption{Navigation zwischen den Ansichten}
\label{fig:abb39}
\end{figure}
% In der Abb.\ref{fig:abb31} sieht man das aufgeklappte Menü der Menüsteuerungsseite der ScanApp. 
Die Xamarin.Forms.MasterDetailPage hat zwei wichtige Properties von Typ Page:
\begin{itemize}
  \item Master - eine ContentPage mit einem Element, nämlich eine TableView, in der die
  unterschiedlichen Navigationspunkte aufgelistet werden.
  \item Detail - je nachdem, welcher Navigationspunkt geklickt wurde, wird eine neue NavigationPage
  erstellt und der Benutzer wird zu der entsprechenden Ansicht (ContentPage) navigiert.
\end{itemize}
Beispielsweise sieht die Navigation zu der Kontakt-Seite folgendermaßen aus:
\\ \textcolor{gray}{\textsl{void onKontaktTapped(object sender, EventArgs e)\\ \{\\ this.Detail
= new NavigationPage(new KontaktPage());\\this.isPresent = false;
\\
\}}}
\\Die Zeile \textcolor{gray}{\textit{this.isPresent = false;}}, sorgt dafür, dass das Menü
automatisch zugeklappt wird, nachdem die ausgewählte Seite aufgemacht wurde.
\subsection{Hardwarenahe Funktionalität: Barcodescanner}
Die Implementierung des Barcodescanners ist einer der wenigen Punkten, bei denen ein Eingriff in
die plattformspezifischen Projekte notwendig ist. Sowie zum ScanApp.iOS als auch zum ScanApp.Droid
muss die Komponente ZXing.Net.Mobile hinzugefügt werden. Diese Komponenete greift auf native APIs
zu, wie die API zur Steuerung der Kamera des Geräts, um die Scanner-Funktion zu
ermöglichen.
Im gemeinsamen Projekt wird das Interface IScanner.cs definiert (Abb.
\ref{fig:abb28}).
In beiden plattformspezifischen Projekte wird je eine Klasse Scanner.cs erstellt, die dieses Interface implementiert. Im Projekt ScanApp kann
man auf die plattformspezifische Scanner.cs Klassen mit:\\
\textcolor{gray}{\emph{DependencyService.Get<IScanner>().Scan()}} zugreifen.
\begin{figure}[!h]
\centering
\includegraphics[scale = 0.7]{graphics/IScanner.png}
\caption{Das Interface IScanner}
\label{fig:abb28}
\end{figure}

%\subsection{Web Services für die Kommunikation mit dem Backend}
% Web Services kommen in den folgenden Fällen zum Einsatz:
% \begin{itemize}
%   \item Bei der einmaligen Registrierung eines Benutzers.
%   \item Beim Überprüfen eines Barcodes.
%   \item Beim Abschließen einer Bestellung.
%   \item Beim Anzeigen des Kundennamen nach der Eingabe einer Kundennummer (Nur im
%   Mitarbeiter-Modus).
% \end{itemize} 
% Im gemeinsamen Projekt wird für diesen Zweck eine Klasse mit jeweils eine Methode für die oben
% genannten vier Fällen erstellt. Alle Methoden der Klasse benutzen den gleichen Http-Client der
% Komponente \textbf{ModernHttpClient}:\\  
% \textcolor{gray}{\emph{HttpClient client = new HttpClient(new
% ModernHttpClient.NativeMessageHandler())}}.
% \\Wie bei jeder App muss man hier beachten, dass mobile Geräte nicht selten einen schlechten oder
% gar keinen Empfang haben. Abhängig vom Netzwerktyp kann die Geschwindigkeit einer Internetverbindung
% stark variieren. Aus diesem Grund ist es wichtig, dass alle Serveranfragen in einem
% separaten Thread ausgeführt werden, so dass der Ablauf der App nicht durch eine schlechte oder
% fehlende Verbindung beeinträchtigt wird. Außerdem kann je nach Tarif der mobile Datenvolumen
% begrenzt oder es können extra Kosten entstehen, wenn eine Bestimmte Grenze von verbrauchten MB pro Monat erreicht
% wird. Aus diesem Grund ist es sinnvoll, dass die App in der Lage ist, den Netzwerktyp zu
% erkennen. D.h. ob die Verbindung über WLAN oder über das mobile Internet erfolgt. Xamarin.Android
% bietet einen Mechanismus für diesen Zweck - durch die Klasse \textbf{NetworkInfo}. Mithilfe dieser Klasse
% kann die App auch erkennen ob Roaming eingeschaltet wurde (\cite{XamNetzwerkStatus}).\\Bei
% Xamarin.iOS gibt es einen ähnlichen Mechanismus.
% \\Der Befehl \textcolor{gray}{\textsl{Reachability.InternetConectionStatus()}} liefert Auskunft
% darüber ob eine Internetverbindung über WLAN, über mobiles Internet erfolgt oder es gar keine
% Verbindung besteht (\cite{XamNetzwerkStatusIOS}). Die Netzwerktyperkennung lässt sich nicht
% plattformübergreifend implementieren, das erfolgt in den plattformspezifischen Projekten.
\subsection{Xamarin Komponenten (Components) und NuGet Packages} \label{nuGetPackages}
Die Möglichkeit, Komponenten und NuGet Packages an ein Projekt anzubinden, ist eine der
größten Stärken von Xamarin.
Da bei Xamarin.Forms Shared Projects keine Komponenten zum gemeinsamen (shared) Projekt
hinzugefügt werden können, müssen die benötigten Komponenten zu den
plattformspezifischen Projekten hinzugefügt werden.
\subsubsection{Xamarin Components}
\begin{itemize}
        \item \textbf{ModernHttpClient} - Für die Kommunikation mit dem Backend wird ein Http-Client
        benötigt. Es gibt mehrere ähnliche Komponenten und NuGet Packages. \\Für die vorliegende
        Arbeit ist die Wahl auf die ModernHttpClient-Komponente gefallen, weil diese          
        vorwiegend sehr positiv in der Xamarin-Community bewertet wird und anders als andere
        ähnliche Packages auch mit dem Protokol Https funktioniert.
        \item \textbf{ZXing.Net.Mobile} - Die Kernfunktionalität der Nüßing ScanApp, nämlich die
        Scan-Funktion wird mithilfe der Xamarin-Komponente ZXing.Net.Mobile gewährleistet. Der
        Entwickler braucht sich nicht um native Funktionen, wie die Nutzung der Kamera und das Ein- und Ausschalten des
        Blitzlichtes, zu kümmern. Diese Funktionalität, sowie die Erkennung des Barcodes wird von der
        ZXing-Komponente bereitgestellt. 
\end{itemize}
\subsubsection{NuGet Packages}
\begin{itemize}
        \item \textbf{Newtonsoft.Json} - Für die Kommunikation mit dem Backend werden Json-Objekte
        benutzt.
        Damit man zu den in einem Json-Objekt enthaltenen Informationen gelangen kann, muss das Objekt
        zerteilt (geparst) werden. Das NuGet Package Newtonsoft.Json macht das Parsen eines
        Json-Objekts zu einer relativ einfache Aufgabe.
        \item \textbf{Xam.Plugin.DeviceInfo} - Beim ersten Start der Applikation, muss der Kunde sich
        einmalig registrieren. Bei der Registrierung wird auch Information über das Gerät
        mitgesendet. Zu dieser nativen Information gelangt man mithilfe des NuGet Packages,
        Xam.Plugin.DeviceInfo.
\end{itemize}
Es gibt eine große Vielfalt an Xamarin Komponenten und NuGet Packages. Somit kann eine
Xamarin Applikation mit mehreren Features angereichert werden. 
\subsection{Fazit}
Mit Xamarin.Forms lässt sich nicht nur die ganze App-Logik im einem Gemeinsamen Projekt
implementieren, sondern auch fast die ganze Benutzungsoberfläche der App. Daraus resultieren zwei
(oder sogar drei, wenn auch eine Windows Phone als Zielplattform erwünscht ist) Versionen der
Anwendung, die alle das native "`Look and Feel"' der jeweiligen Plattform haben. Die gemeinsame
Codebasis erleichtert nicht nur den Entwurf, sondern auch das Fixen von Bugs und die Wartung der
App.
