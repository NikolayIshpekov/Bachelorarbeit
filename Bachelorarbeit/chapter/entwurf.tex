\chapter{Entwurf für die Entwicklung mit Xamarin}
In diesem Abschnitt wird der Entwurf der Scan-App mit Xamarin.Forms beschrieben. 
Es wird das für Xamarin.Forms übliche MVVM-Muster angewendet.\\Bei Xamarin.Forms gibt es zwei
alternative Methoden zum Code-Sharing:
 Shared Projects und Portable Class Libraries (PCL). Da im vorliegenden Fall Code-Sharing nur
 innerhalb der Applikation vorgesehen wurde, wird Shared Projects gewählt (der PCL
 Ansatz wird für den Fall empfohlen, wenn ein Entwickler seinen Code für andere Developer in Form
 einer DLL Bibliothek bereitstellen möchte).
 Der Sinn von Xamarin.Forms ist es, dass man mit einer gemeinsamen Codebasis, mehrere Versionen
 einer App erstellen kann (im vorliegenden Fall sind es iOS- und Android-Version der Anwendung.
 Mit einem Xamarin Business Account wäre auch eine Windows Phone-Version möglich).
\begin{figure}[!h]
\centering
\includegraphics[scale = 0.7]{graphics/ScanApp_Projekt.png}
\caption{ScanApp - Entwurf}
\label{fig:abb40}
\end{figure}
\newline
Abb. \ref{fig:abb40} veranschaulicht die Verteilung der Projekten.
Der Großteil des Codes wird sich im plattformübergreifenden Projekt, ScanApp befinden. In diesem
"`shared"' Projekt wird typischerweise die gesamte App-Logik, inklusive Gestaltung der
Benutzungsoberfläche, ausgelagert. 
% Xamarin.Forms ist eine Art Abstraktionsschicht, mit derer Hilfe
% sich die Benutzungsoberfläche in diesem gemeinsamen, plattformübergreifenden Projekt gestalten
% lässt.
Die Benutzungsoberfläche (in English: graphical user interface (GUI)) muss den Designvorgaben der
unterschiedlichen Betriebssystemhersteller folgen, damit die App zu den entsprechenden App-Stores
zugelassen wird.
Der Entwickler soll sich, allerdings, nicht darum kümmern, diese Aufgabe erledigt Xamarin. Da der Xamarin-Code pro Plattform zu Maschinencode
kompiliert wird, ist der App nicht anzusehen, dass sie "`cross-plattform"' entwickelt wurde.
Aus der Perspektive eines Benutzers fühlt sich eine Xamarin App wie jede native iOS bzw. Android App
an. 
\\Mittels Xamarin.Forms werden die Ansichten komplett plattformunabhängig definiert. 
Die Xamarin.Forms Steuerelemente werden je nach Plattform in das native Pendant übersetzt.
So wird ein "`Xamarin.Forms.ListView"' in "`ListView"' bei Android und in "`UITableView"' bei iOS übersetzt
\\In die
Projekte ScanApp.Droid und ScanApp.iOS gehören App-Ressourcen wie bspw.
Icons, sowie eventuell benutzerdefinierte Renderer. Die sogenannten "`Custom Renderer"' werden für
die Implementierung von benutzerdefinierten Steuerelementen und Ansichten benötigt, die mit den von
Xamarin.Forms zur Verfügung gestellten Werkzeugen nicht zu realisieren sind.
\\Außer als Container für benutzerdefinierte Renderer und App-Ressourcen, werden in den
plattformspezifischen Projekte noch Einstellungen vorgenommen, wie Info.plist im iOS-Projekt oder
AndroidManifest.xml bei Android. 
Wie aus Abb. \ref{fig:abb40} ersichtlich, lassen sich beim Shared Projects-Ansatz keine "`open
source"' Bibliotheken, wie NuGet Packages oder Xamarin Komponenten direkt an das gemeinsame Projekt anbinden.
Das erfolgt in den plattformspezifischen Projekte. Eine solche Xamarin Komponente ist bspw. die ZXing-Komponente zum Scannen von Barcodes, die
eine zentrale Rolle in der App spielt. Das ebenso in der ScanApp eingebundene NuGet Package
"`DeviceInfo"' bietet eine API, mit der Entwickler Informationen über das Smartphone bekommen
können. Am Ende dieses Kapitels werden die für die ScanApp benötigten NuGut Packages und Xamarin
Komponenten näher vorgestellt. 
% \\Der Entwurf der ScanApp bezieht sich fast ausschließlich auf das
% "`shared"' Projekt (siehe Abb. \ref{fig:abb40}). 
\\Es ist nahe liegend, dass bei einer
"`Cross-Plattform-Entwicklung"' gezielt wird, dass alle Gemeinsamkeiten in das
"`shared"' Projekt ausgelagert werden. Die plattformspezifischen Projekte sollten möglichst
"`klein"' bleiben.
Im Folgenden wird einen Einblick in den Entwurf der Anwendung gegeben.
\begin{figure}[!h]
\centering
\includegraphics[scale = 0.46]{graphics/SharedScanApp.png}
\caption{ScanApp - Entwurf (Shared Projekt)}
\label{fig:abb41}
\end{figure}
% \\Sollte eine
% Anforderung nicht plattformübergreifend zu gewährleisten sein, muss diese Funktionalität in den
% plattformspezifischen Projekten implementiert werden. Im gemeinsamen Projekt wird ein Interface
% definiert, das von den dafür zuständigen Klassen in ScanApp.Droid und ScanApp.iOS implementiert
% werden muss.
% Die angeforderte Funktionalität wird in den plattformspezifischen Projekten implementiert. Dieses
% Interface muss von den jeweiligen Klassen, die die Funktionalität gewährleisten, der plattformspezifischen Projekte implementiert.
% Der Zugriff aus dem plattformübergreifenden Projekt erfolgt folgendermaßen:\\
% \textcolor{gray}{\emph{DependencyService.Get<InterfaceName>().PlattformSpecificMethodName()}}.
% \subsection{Umsetzung des MVVM-Architekturmusters}
% Wie bereits im Kapitel \ref{MVVM} erörtert, weist das MVVM-Pattern eine lose Kopplung
% zwischen View und Viewmodel auf. Um diese Trennung visuell zu gestalten, werden drei Ordner erstellt:
% \begin{itemize}
%   \item \textbf{Model} - Im Ordner Model werden typischerweise Klassen defniert, die
%   anwendungsspezifische Datentypen beschreiben. Das sind Klassen zur Speicherung und
%   Verarbeitung von Daten, die dafür sorgen, dass die Daten konsistent gehalten
%   werden.
%   \item \textbf{View} - Alle Ansichten (Xaml-Datein, die vom Typ Xamarin.Forms.Page oder
% Xamarin.Forms.View sind oder von diesen Klassen erben) gehören in den Ordner View.
%   \item \textbf{Viewmodel} - In den Viewmodel-Ordner kommen die Viewmodel-Klassen (C\#-Klassen,
%   die das Interface \textbf{\textit{INotifyPropertChanged}} implementieren). 
% \end{itemize}
% Jede Ansicht wird an ein Viewmodel gebunden. Das wird durch das sogenannte "`Data
% Binding"' (in Deutsch Datenbindung) realisiert.
% % In Abb.\ref{fig:abb23} sieht man eine typische
% % Xaml-Datei, die eine Ansicht beschreibt und sich im Ordner View befindet. Diese Ansicht wird
% % von der benutzerdefinierten Base\_Page abgeleitet, die ihrerseits von der Klasse Xamarin.Forms.Page
% % abgeleitet wird.
%  In einer C\#-Klasse, genannt Base\_Page, werden Eigenschaften und Methoden definiert, die für die
%  meisten Ansichten gemeinsam sind. Bspw. das Navigationsheader-Logo oder Methoden für die Steuerung
% der Navigation. Diese Klasse wird von der Klasse Xamarin.Forms.Page abgeleitet.
% % \\Eine der wichtigsten Klassenvariablen der Klasse Xamarin.Forms.Page ist das Property
% % \textit{BindingContext}.
% % Mithilfe dieser Eigenschaft wird ein Viewmodel (in diesem Fall das HeaderDataEditViewModel) an der Page-Klasse gebunden (Siehe
% % \ref{fig:abb23}, Zeile 23-25).
% % \\In Zeile 12 findet eine typische Datenbindung ("`data binding"') statt.
% % Das Text-Property eines Entry-Textfeldes wird an das Property \textit{Name} gebunden, das im
% % Viewmodel definiert wird (siehe Abb.\ref{fig:abb33}).
% % Sobald der Text des Textfelds sich ändert, wird das Viewmodel darüber informiert. Diese Bindung
% % funktioniert in beiden Richtungen, d.h. Änderungen, die im Viewmodel vorgenommen werden, werden in
% % der Ansicht angezeigt.\\In Abbildung \ref{fig:abb23}, Zeile 20 ist die Definition eines
% % Toolbarbuttons zu sehen. Sobald dieser Button gedrückt wird, wird ein Command ausgeführt, das an
% % das Property \textit{SaveUserDataCommand} des Viewmodels gebunden ist. D.h. dieses Klick-Event
% % löst den Aufruf einer Methode in der Viewmodel-Klasse auf.\\Das Ganze veranschaulicht, welche
% % Vorteile das MVVM-Architekturmuster mit sich bringt.
% Durch die Datenbindung entsteht eine lose Kopplung zwischen View und ViewModel. Da das Viewmodel die
% Views nicht kennt, lässt sich eine Ansicht problemlos durch eine andere austauschen. Die neue
% Ansicht muss lediglich an das Viewmodel gebunden werden.
% \\Ein ViewModel muss zwingend das Interface \textbf{\textit{INotifyPropertChanged}} implementieren.
% Dadurch können sogenannte "`Bindable Properties"` definiert werden
% %  (siehe Abb.\ref{fig:abb33})
% . Bei jeder Änderung wird die OnPropertyChanged()-Methode mit dem Property-Name als String-Parameter
% aufgerufen und dadurch wird ein PropertyChangedEventHandler ausgelöst.
% \\Wie bei den meisten Applikationen, sind auch für die Scan-Anwendung mehrere Ansichten
% erforderlich. Es stellt sich die Frage, wie wird zwischen den verschiedenen Seiten gewechselt?\\Um
% zwischen den Ansichten navigieren zu können, wird eine Instanz der Klasse \textit{NavigationPage}
% benötigt: \textit{new NavigationPage(new Page())}. 
% \\Jede Xamarin.Forms.Page-Klasse hat über das Property \textbf{\textit{Navigation}} Zugriff auf das
% NavigationPage: \textit{this.Navigation.PushAsync(new Page())}.\\Nach dem MVVM-Muster sollten sich
% die Viewmodel-Klassen um die Navigation kümmern.
% Allerdings ist \textit{Navigation} ein Property der Ansicht. D.h. das Viewmodel muss signalisieren,
% dass es zu einer anderen Ansicht gewechselt werden soll. Da das Viewmodel die Ansicht nicht kennt,
% kann das durch das \textbf{\textit{Xamarin.Forms Messaging Center}} erreicht werden. Die Ansicht
% abonniert Navigationsnachrichten des Viewmodels und wird somit immer informiert, wenn die
% Seite gewechselt werden soll.

% \begin{itemize}
%   \item Das Framework MVVM-Light
%   \item Messaging
%   \item unsaubere Anwendung von MVVM, wie z.B. das Property NavigatioPage einer Ansicht dem
%   zugehörigen ViewModel mitzugeben. Das würde die Navigation aus dem ViewModel ermöglichen, aber
%   es verletzt eine der Grundideen von MVVM ist es, dass der ViewModel die View nicht kennt.
% \end{itemize}


% \begin{figure}[!h]
% \centering
% \includegraphics[scale = 0.435]{graphics/Typische_Xaml_Datei.png}
% \caption{Typische Xaml-Datei}
% \label{fig:abb23}
% \end{figure}
% \begin{figure}[!h]
% \centering
% \includegraphics[scale = 0.6]{graphics/Bindable_Property.png}
% \caption{Definition von Bindable Property}
% \label{fig:abb33}
% \end{figure}

% Da beim gemeinsamen ScanApp Projekt keine Bibliotheken eingebunden werden können, muss man einen
% SQLite.cs File aus Github herunterladen und in das gemeinsame Projekt kopieren. Dieser C\#-File
% benutzt Compiler Direktiven um mehrere Plattformen in derselben Codebasis zu unterstützen.
% \\Um SQLite in einer Xamarin.iOS oder Android Applikation benutzen zu können, muss man angeben, wo
% der Datenbank File zu finden ist (es ist abhängig vom
% Ziel-Plattform unterschiedlich). Für iOs und Android kann man "`Environment class"' benutzen um einen
% validen Pfad zu konstruieren (siehe Abb. \ref{fig:abb27}). Mittels Compiler Direktiven lassen sich
% spezielle Pfade für jede Plattform generieren.\\Um sicher zu gehen, dass der Code nicht versucht,
% auf die SQLite Datenbank aus verschiedenen "`multiple Threads"' zuzugreifen wird manuel ein "`lock"'
% benutzt. Z.B.\\object locker = new object();\\lock(locker)\{ Datenbankquery \};\\Alle
% Datenbankzugriffe sind mit demselben "`lock"' gekapselt, wobei hier Vorsicht geboten ist. Es könnten
% Deadlocks entstehen! 
% \begin{figure}[!h]
% \centering
% \includegraphics[scale = 0.4]{graphics/SQLitePath.png}
% \caption{SQLite Pfad}
% \label{fig:abb27}
% \end{figure}
\section{Shared ScanApp Projekt}
In Abb. \ref{fig:abb40} wird der grobe Entwurf der ScanApp abgebildet. Wie schon angemerkt, passiert
das wesentliche im gemeinsamen Projekt (Shared Projekt). Abb. \ref{fig:abb41} bildet die Struktur
des Shared ScanApp Projekts ab. 
% Im Folgenden wird einen Einblick in die Komponenten dieses Projekts
% gegeben. 
Wie bereits im Kapitel \ref{MVVM} erläutert, weist das MVVM-Pattern eine lose Kopplung
zwischen View und Viewmodel auf.\\Im Folgenden werden die Komponente des Projekts beschrieben.
\subsection{Model}
In der Komponente Model werden typischerweise Klassen definiert, die
  anwendungsspezifische Datentypen beschreiben. Das sind Klassen zur Speicherung und
  Verarbeitung von Daten, die dafür sorgen, dass die Daten konsistent gehalten
  werden.
D.h. zum Model gehören die eigentlichen Daten der Anwendung. Hier werden Klassen, wie Barcode,
UserData, Order, OrderItem etc. definiert.\\Im Model wird noch eine Klasse definiert, die
Methoden für "`CRUD"'-Operationen (Create Read Update Delete) für das Persistieren der Modeldaten in
die Datenbank (die in \ref{PersistenzBackend} vorgestellt wird) bietet.
\subsection{View}\label{View}
In der View-Komponente werden die Ansichten der Bedienungsoberfläche der App definiert. 
Die grafischen Interfaces der Scan-App werden mit der Markupsprache Xaml
beschrieben. Somit wird eine strikte Trennung zwischen dem Oberflächendesign (in einer
Xaml-Datei beschrieben) und der Funktionalität (in einer an der Xaml-Datei gebundenen C\#-Datei aus
der Komponente ViewModel implementiert) erreicht.
\\An dieser Stelle lässt es sich anmerken, dass Xamarin Entwicklern die Wahl zwischen der
Markupsprache Xaml und C\# für die Implementierung der UIs (User Interfaces) lässt, wobei beide
Techniken zum gleichen Ergebnis führen. D.h. die Verwendung von Xaml für die Beschreibung der
Benutzungsoberfläche ist keine Pflicht, allerdings ist der C\#-Code schwerer lesbar als der
Xaml-Code. Aus diesem Grund wird für die vorliegende Arbeit die Xaml-Technik angewendet.
% \\Aus diesem Grund werden die grafischen Interfaces der Scan-App mit der Markupsprache Xaml
% beschrieben. Somit wird eine strikte Trennung zwischen dem Oberflächendesign (in einer
% Xaml-Datei beschrieben) und der Funktionalität (in der an der Xaml-Datei gebundenen
% Viewmodel-C\#-Datei implementiert) erreicht.
Dieser Ansatz macht Wiederverwendbarkeit und Austauschbarkeit einer Ansicht möglich und Designer und
Entwickler können unabhängig voneinander arbeiten.
% In Abb. \ref{fig:abb34} werden die Mockups für die unterschiedelichen Ansichten der Scan-App
% abgebildet.
In Abb. \ref{fig:abb34} werden Mockups der zu definierenden Scan-App Ansichten dargestellt.
% Jede Ansicht wird in Form einer Xamarin.Forms.Page definiert und in einer Xaml-Datei gespeichert. 
% In einer C\#-Klasse, genannt Base\_Page, die von der Klasse Xamarin.Forms.Page abgeleitet wird,
% werden Eigenschaften definiert, die für die meisten Ansichten gemeinsam sind. Bspw. das
% Navigationsheader-Logo oder Methoden für die Steuerung der Navigation. Von dieser Klasse werden die
% Ansichten abgeleitet.
\begin{figure}[!h]
\centering
\includegraphics[scale = 0.65]{graphics/MockUpsScanApp.png}
\caption{GUI Mockups}
\label{fig:abb34}
\end{figure}
\subsection{ViewModel}
In der Viewmodel-Komponente kommen die Viewmodel-Klassen (C\#-Klassen, die das Interface
\textbf{\textit{INotifyPropertChanged}} implementieren). Jede der in der Komponente View definierten
Ansichten, wird an eine ViewModel-Klasse gebunden. Während eine Xaml-Datei, eine reine
Beschreibung der Ansicht ist, wird in einer ViewModel-Klasse die Logik hinter dieser Ansicht
implementiert. Hier werden Properties und Methoden definiert, die durch "`Data Binding"' an
Steuerelemente der dazugehörenden View gebunden werden. \\Die Klassen der ViewModel-Komponente
greifen auf die Klassen der Util- und der Model-Komponente zu, um die Funktionalität der App zu
gewährleisten und sind auch für die Navigation zwischen der App-Seiten, die im
\ref{Navigation} beschrieben wird, zuständig. \\Da nach MVVM die View den ViewModel kennt und der
ViewModel über keine Information über die View verfügt, kann eine ViewModel-Klasse
ausschließlich durch das \textbf{\textit{Xamarin.Forms Messaging Center}} mit der entsprechenden
View-Klasse "`kommunizieren"'.
\subsection{Util}
In dieser Komponente werden einige nützliche Klassen definiert, wie bspw.
 eine UtilKlasse mit mehreren statischen Methoden, die von den Klassen des Viewmodels benutzt
  werden oder auch Klassen, die die Kommunikation mit dem Backend mittels Web Services ermöglichen.
  Ebenso wird hier noch eine Klasse mit App-Konstanten definiert. Hier werden üblicherweise
  vorwiegend Strings ausgelagert.
\section{Datenpersistenz und Backend-Kommunikation}\label{PersistenzBackend}
Fast jede mobile Anwendung braucht einen Mechanismus, der eine dauerhafte lokale Speicherung der
Appdaten erlaubt. Das gilt besonders für die Kategorie der Business Apps, zu der die zu entwickelnde
ScanApp auch zählt. Typischerweise wird zu diesem Zweck eine leichtgewichtige Datenbank, namens
SQLite benutzt.
\\Die "`open-source"' Datenbank SQLite ist gut geeignet für das Persistieren von Daten von mobilen
Applikationen, weil:
\begin{itemize}
  \item die Datenbank klein, schnell und leicht portierbar ist;
  \item der Fileformat leicht zu benutzen und plattformübergreifend ist;
  \item SQLite die meisten SQL92 Standards implementiert.
\end{itemize}
Darüber hinaus ist SQLite die Standardlösung für Datenpersistierung bei der nativen
Android-App-Entwicklung und sehr verbreitet bei der iOS-App-Entwicklung.
\\Xamarin.Forms unterstützt die Anbindung von SQLite und zwar cross-plattform. In den
plattformspezifischen Projekte muss lediglich jeweils eine SQLite-Datei zu den Ressourcen
hinzugefügt werden. Im geteilten Projekt muss der Pfad zu der SQLite-Datenbank angegeben werden,
einmal für Android und einmal für iOS. Die Zugriffe auf die Datenbank erfolgen plattformübergreifend (d.h. aus dem
"`shared"' Projekt).

Ein weiterer wichtiger und häufig vorkommender Punkt bei der Entwicklung von Apps, ist die
Kommunikation mit dem Backend. Ähnlich wie die Anforderung für dauerhafte lokale Speicherung der App
Daten, müssen viele Apps (vor allem Business Apps) mit einem Server über das Internet kommunizieren.
Diese Kommunikation erfolgt über sogenannte Web Services.
\\Stellvertretend für die meisten Apps dieser Kategorie, kommt es bei der ScanApp in den
folgenden Fällen zum Einsatz von Web Services:
\begin{itemize}
  \item Bei der einmaligen Registrierung eines Benutzers.
  \item Beim Überprüfen eines Barcodes.
  \item Beim Abschließen einer Bestellung.
\end{itemize} 
Das sind drei typische Interaktionen zwischen App und Backend. Im Prinzip ist es belanglos,
wofür konkret Web Services eingesetzt werden, weil sie immer nach dem gleichen Muster funktionieren.
Die App sendet eine Anfrage, im vorliegenden Fall in Form eines Json-Objekts (oft werden auch XML-Dateien zwischen App
und Server ausgetauscht, wobei bei XML der Overhead größer ist) und der Server antwortet
mit einer Datei desselben Formats. Damit die Kommunikation gelingt, müssen sich Server und Client an
einem Vertrag halten. In diesem Vertrag wird die Struktur des Json-Objekts definiert. D.h.
die App muss in der Lage sein, dieses Objekt zu zerteilen (parsen), um die Antwort vom Server
verstehen zu können. Für das Parsen eines Json-Objekts wird das NuGet Package \textbf{Newtonsoft.Json} in 
die Projekte ScanApp.iOS und ScanApp.Droid eingebunden. Die Kommunikation erfolgt mit dem
Http-Client der Xamarin Komponente \textbf{ModernHttpClient}, die ebenso in die
plattformspezifischen Projekte eingebunden werden muss.\\Die Implementierung ist allerdings
plattformübergreifend. Im gemeinsamen Projekt wird eine Klasse (siehe Abb. \ref{fig:abb41}, die
Klassse HttpBackend in der Util-Komponente) mit jeweils eine Methode für die oben genannten drei
Fällen erstellt.
% \\  
% \textcolor{gray}{\emph{HttpClient client = new HttpClient(new
% ModernHttpClient.NativeMessageHandler())}}.
\\Wie bei jeder App muss man hier beachten, dass mobile Geräte nicht selten einen schlechten oder
gar keinen Empfang haben. Abhängig vom Netzwerktyp kann die Geschwindigkeit einer Internetverbindung
stark variieren. Aus diesem Grund ist es wichtig, dass alle Serveranfragen in einem
separaten Thread ausgeführt werden, so dass der Ablauf der App nicht durch eine schlechte oder
fehlende Verbindung beeinträchtigt wird. Außerdem kann je nach Tarif der mobile Datenvolumen
begrenzt oder es können extra Kosten entstehen, wenn eine Bestimmte Grenze von verbrauchten MB pro Monat erreicht
wird. Aus diesem Grund ist es sinnvoll, dass die App in der Lage ist, den Netzwerktyp zu
erkennen. D.h. ob die Verbindung über WLAN oder über das mobile Internet erfolgt. Xamarin.Android
bietet einen Mechanismus für diesen Zweck - durch die Klasse \textbf{NetworkInfo}. Mithilfe dieser Klasse
kann die App auch erkennen ob Roaming eingeschaltet wurde [\cite{XamNetzwerkStatus}].\\Bei
Xamarin.iOS gibt es einen ähnlichen Mechanismus.
\\Der Befehl \textcolor{gray}{\textsl{Reachability.InternetConectionStatus()}} liefert Auskunft
darüber ob eine Internetverbindung über WLAN, über mobiles Internet erfolgt oder es gar keine
Verbindung besteht [\cite{XamNetzwerkStatusIOS}]. \\Die Netzwerktyperkennung lässt sich nicht
plattformübergreifend implementieren, das erfolgt in den plattformspezifischen Projekten. Im Sinne von "`Cross-Plattform-Entwicklung"' wird für solche Fälle ein Interface im gemeinsamen Projekt definiert. Dieses Interface wird dann in den plattformspezifischen Projekten implementiert. Auf
diese Weise lässt sich die Netzwerktyperkennung aus dem "`shared"' Projekt steuern und
dementsprechend behandeln. Da bei der ScanApp eine Übertragung von
größeren Dateien, wie bspw. Bilder nicht vorgesehen ist, ist eine Netzwerktyperkennung unnötig und
es wurde darauf verzichtet.

% Die Benutzungsoberfläche (in English: graphical user interface (GUI)) soll den Designvorgaben der
% unterschiedlichen Betriebssystemhersteller folgen. Der Entwickler soll sich, allerdings, nicht darum
% kümmern, diese Aufgabe erledigt Xamarin. Der Xamarin-Code wird pro Plattform zu Maschinencode
% kompiliert und dadurch erweckt die App den Eindruck, Teil der konkreten Plattform zu sein. D.h.
% aus der Perspektive eines Benutzers fühlt sich eine Xamarin.iOS App wie jede native iOS App an.
% Selbstverständlich gilt dasselbe für eine Xamarin.Android App. \\In Abb.
% \ref{fig:abb34} werden die Mockups für die unterschiedelichen Ansichten der Scan-App abgebildet. 
% Die GUI wird mit wenigen Ausnahmen im gemeinsamen Projekt, ScanApp erstellt.
% Xamarin lässt Entwicklern die Wahl zwischen der Markupsprache Xaml und C\# für die Implementierung
% der UIs (User Interfaces), wobei beide Techniken zum gleichen Ergebnis führen. \\Die
% Positionierung der Steuerelemente und deren Funktionalität lassen sich in einer C\#-Datei
% implementieren, allerdings ist der Code schwer lesbar und nicht wiederverwendbar.\\Aus diesem
% Grund werden die grafischen Interfaces der Scan-App mit der Markupsprache Xaml beschrieben.
% Somit wird eine strikte Trennung zwischen dem Oberflächendesign (in einer
% Xaml-Datei beschrieben) und der Funktionalität (in der an der Xaml-Datei gebundenen
% Viewmodel-C\#-Datei implementiert) erreicht.
% Diese Technik macht Wiederverwendbarkeit und Austauschbarkeit einer Ansicht möglich und Designer und
% Entwickler können unabhängig voneinander arbeiten. \\Bei der Erstellung einer Xamarin.Forms
% ContentPage Xaml-Datei wird automatisch auch die zugrundeliegende C\#-Datei, bekannt auch als "`Code-Behind-Datei"', angelegt (siehe Abb. \ref{fig:abb21}).
% Diese Code-Behind-Datei sollte bei einer sauberen Umsetzung des MVVM-Patterns außer des Aufrufs der
% \emph{InitializeComponent()} Methode im Konstruktor und der bereits erwähnten Methoden, die
% Viewmodelnachrichten abonnieren und die Navigation steuern, komplett leer sein.
% Es ist möglich, dass die Funktionalität eines Viewmodels in der Code-Behind-Datei einer Ansicht
% untergebracht wird. Das entspricht, allerdings, nicht dem MVVM-Architekturmuster. Dadurch
% würde eine sehr enge Kopplung zwischen View und Funktionalität entstehen und die Ansichten wären
% nicht mehr austauschbar.\\Durch Xamarin.Forms kann man die ganze Benutzungsoberfläche im gemeinsamen
% Projekt implementieren. D.h. jede Erweiterung oder Änderung einer Ansicht kann zentral, an einer
% Stelle, durchgeführt werden. Sollte man zu einem späteren Zeitpunkt Design-Änderungen vornehmen
% möchten, müsste man es dann nur einmal implementieren.\\Da der gemeinsame Code zu nativem
% Maschinencode kompiliert wird und die Steuerelemente die gleiche Funktionalität haben, sieht die
% Android-Benutzungsoberfläche nicht unbedingt gleich wie die von iOS oder eventuell die von Windows
% Phone aus.\\Ein Eingriff in die plattformspezifischen Projekte, ist nur in den Fällen notwendig,
% wenn die von Xamarin.Forms angebotenen Steuerelemente sich nicht so verhalten wie der Entwickler bzw. der Designer der App es sich vorstellt. Dann werden sogenannte
% "`Custom Renderer"' Klassen in die plattformspezifischen Projekten benötigt. In denen kann man
% Änderungen vornehmen, wie z.B. das Definieren von runden Buttons. \\Die Layouts der  mit
% Xamarin.Forms erstellten Ansichten passen sich dynamisch an die Größe des Bildschirms an.
% Bei den vielen verschiedenen Geräten ist das eine wesentliche Erleichterung für den Entwickler. 
% \begin{figure}[!h]
% \centering
% \includegraphics[scale = 0.7]{graphics/XamlDateiPlusCSDatei.png}
% \caption{Xaml-Datei und die zugrundeliegende C\#-Datei}
% \label{fig:abb21}
% \end{figure}
% 
% \begin{figure}[!h]
% \centering
% \includegraphics[scale = 0.65]{graphics/MockUpsScanApp.png}
% \caption{GUI Mockups}
% \label{fig:abb34}
% \end{figure}
% \\Der Aufbau einer Xaml-Datei ist dem Gerüst eines XML-Dokuments sehr ähnlich. Es gibt ein
% Wurzelelement und jedes Element kann Attribute besitzen. Dadurch entsteht eine übersichtliche Hierarchie der Elemente
% (Siehe \ref{fig:abb23}).
% Durch das Attribut x:Name könnte man auf das Element aus der Code-Behind-Datei zugreifen und bspw. den
% Text eines Labels oder die Textfarbe setzen. 
% (siehe \ref{fig:abb26}).

% \\In Abbildung \ref{fig:abb25} sieht man die zugrundeliegenden C\#-Datei, in der z.B. die
% Funktionalität der Toolbar-Buttons implementiert ist. Beim Klick auf den Button zum Speichern der
% Angaben, werden die Texten der Texteingabefeldern in einem Objekt vom Typ Kopfdaten gespeichert und
% anschließend wird das neu erstellte Objekt in die SQLite-Datenbank gespeichert. Beim Klick auf den
% Müllkorb-Button, werden die gespeicherten persönlichen Daten aus der SQLite-Datenbank gelöscht. 
% \begin{figure}[!h]
% \centering
% \includegraphics[scale = 0.7]{graphics/XamlDateiPlusCSDatei.png}
% \caption{Xaml-Datei und die zugrundeliegende C\#-Datei}
% \label{fig:abb21}
% \end{figure}
% \begin{figure}[!h]
% \centering
% \includegraphics[scale = 0.435]{graphics/Typische_Xaml_Datei.png}
% \caption{Typische Xaml-Datei}
% \label{fig:abb23}
% \end{figure}

% \begin{figure}[!h]
% \centering
% \includegraphics[scale = 0.3]{graphics/appScreenshots/PersoenlicheDaten.png}
% \caption{Screenshot: Seite zum Editieren der persönlichen Daten eines Nutzers der ScanApp}
% \label{fig:abb24}
% \end{figure}

% \begin{figure}[!h]
% \centering
% \includegraphics[scale = 0.4]{graphics/HeaderDatenCSDatei.png}
% \caption{Zugrundeliegende (Code-Behind) C\#-Datei}
% \label{fig:abb26}
% \end{figure}


% \begin{figure}[!h]
% \centering
% \includegraphics[scale = 0.5]{graphics/HeaderDatenToolbar.png}
% \caption{Zugrundeliegende C\#-Datei}
% \label{fig:abb25}
% \end{figure}

\section{Entwurf der Seiten-Navigation}\label{Navigation} 
Beim erstmaligen Starten der App, wird ein Login-Screen angezeigt (siehe Abb. \ref{fig:abb34}) und der
Benutzer wird aufgefordert sich zu registrieren. Im Falle einer erfolgreichen Registrierung, wird zu der Startansicht
navigiert, nämlich die Menüführung Ansicht. Nachdem der Benutzer sich einmal registriert hat, wird
die App immer bei dieser Ansicht gestartet.
In \ref{fig:abb39} wird die Navigation zwischen der verschienden Ansichten der App veranschaulicht. 
\\Der User hat folgende Menüpositionen zur Auswahl:
\begin{itemize}
  \item Persönliche Daten
  \item Bestellungsdaten
  \item Scan
  \item Manuelle Eingabe
  \item Favoriten
  \item Bestellung (Warenkorb)
  \item Scan Historie
  \item Abgeschlossene Bestellungen
  \item Kontakt
\end{itemize}
Je nachdem, welcher Menüpunkt ausgewählt wurde, wird zu der entsprechenden Ansicht navigiert. Die
Ansichten Scan, Manuelle Eingabe, Favoriten und Scan Historie haben alle gemeinsam, dass beim
Auswählen eines Produkts, bzw. eine Barcodenummer, eine neue Ansicht aufgemacht wird, in der
Informationen über das Produkt angezeigt werden. Mit dem "`Back"'-Button kann man dann zurück zu der
vorherigen Ansicht navigieren. Bei der Bestellung Ansicht hat man die Möglichkeit, eine
Bestellposition auszuwählen, dann wird zu einer Seite navigiert, in der folgende Optionen
angeboten werden:
\begin{itemize}
  \item Bestellmenge ändern.
  \item Produkt zu den Favoriten hinzufügen.
  \item Bestellposition löschen.
\end{itemize}
Mit dem "`Back"'-Button wird zurück zu der Warenkorb-Ansicht navigiert.
In der Ansicht Abgeschlossene Bestellungen kann mit Klick auf eine Bestellung zu einer Ansicht
navigiert werden, in der die einzelnen Bestellungspositionen angezeigt werden. Mit dem
"`Back"'-Button wird zurücknavigiert.
\begin{figure}[!h]
\centering
\includegraphics[scale = 0.45]{graphics/ScanApp_Navigation_new.png}
\caption{Navigation zwischen den Ansichten}
\label{fig:abb39}
\end{figure}
\section{Hardwarenahe Funktionalität: Barcodescanner}
Die Struktur der App wurde im "`shared"' Projekt definiert. 
Xamarin.Forms ist eine Art Abstraktionsschicht. Man kann es als die Schnittmenge aller
Funktionalitäten betrachten, die sich im geteilten Projekt implementieren lassen. Die
meisten Funktionalitäten lassen sich auf diese Weise "`cross-plattform"'
realisieren, jedoch gibt es Situationen, bei denen ein Feature nicht plattformübergreifend
umgesetzt werden kann. Typischerweise sind es hardwarenahe Funktionalitäten, wie bspw. Zugriff auf
spezielle Sensoren des Endgeräts.\\Im vorliegenden Fall ist die Implementierung des Barcodescanners
einer der wenigen Punkten, bei denen ein Eingriff in die plattformspezifischen Projekte notwendig
ist. Sowie zum ScanApp.iOS, als auch zum ScanApp.Droid muss die Xamarin Komponente ZXing.Net.Mobile
hinzugefügt werden. Diese Komponente greift auf native APIs zu, wie die API zur Steuerung der Kamera des Geräts,
um die Scanner-Funktion zu ermöglichen. 
% Da sich diese Funktionalität nicht plattformübergreifend implementieren lässt, 
% muss das in den zwei
% plattformspezifischen Projekten (ScanApp.iOS und ScanApp.Android) erfolgen. 
In beiden Projekten wird
je eine Klasse Scanner.cs erstellt, in der mithilfe der von der ZXing.Net.Mobile bereitgestellten
API die Funktionalität des Scanners implementiert wird. 
\\Der Programmablauf wird im geteilten Projekt gesteuert. Im "`shared"' Projekt wird zu
diesem Zweck ein Interface definiert, das von den Scanner-Klassen der plattformspezifischen Projekte
implementiert wird. Der für die Scan-Ansicht zuständige ViewModel führt die Methode
ScanClicked() aus, wenn auf den Scan-Button geklickt wird. 
% Der Scanner wird in einem separaten
% Thread gestartet. Erst wenn eine Barcodenummer erkannt wurde, wird die Barcodenummer dem Main-Thread
% übergeben und der Scanner-Thread wird geschlossen.

%\subsection{Web Services für die Kommunikation mit dem Backend}
% Web Services kommen in den folgenden Fällen zum Einsatz:
% \begin{itemize}
%   \item Bei der einmaligen Registrierung eines Benutzers.
%   \item Beim Überprüfen eines Barcodes.
%   \item Beim Abschließen einer Bestellung.
%   \item Beim Anzeigen des Kundennamen nach der Eingabe einer Kundennummer (Nur im
%   Mitarbeiter-Modus).
% \end{itemize} 
% Im gemeinsamen Projekt wird für diesen Zweck eine Klasse mit jeweils eine Methode für die oben
% genannten vier Fällen erstellt. Alle Methoden der Klasse benutzen den gleichen Http-Client der
% Komponente \textbf{ModernHttpClient}:\\  
% \textcolor{gray}{\emph{HttpClient client = new HttpClient(new
% ModernHttpClient.NativeMessageHandler())}}.
% \\Wie bei jeder App muss man hier beachten, dass mobile Geräte nicht selten einen schlechten oder
% gar keinen Empfang haben. Abhängig vom Netzwerktyp kann die Geschwindigkeit einer Internetverbindung
% stark variieren. Aus diesem Grund ist es wichtig, dass alle Serveranfragen in einem
% separaten Thread ausgeführt werden, so dass der Ablauf der App nicht durch eine schlechte oder
% fehlende Verbindung beeinträchtigt wird. Außerdem kann je nach Tarif der mobile Datenvolumen
% begrenzt oder es können extra Kosten entstehen, wenn eine Bestimmte Grenze von verbrauchten MB pro Monat erreicht
% wird. Aus diesem Grund ist es sinnvoll, dass die App in der Lage ist, den Netzwerktyp zu
% erkennen. D.h. ob die Verbindung über WLAN oder über das mobile Internet erfolgt. Xamarin.Android
% bietet einen Mechanismus für diesen Zweck - durch die Klasse \textbf{NetworkInfo}. Mithilfe dieser Klasse
% kann die App auch erkennen ob Roaming eingeschaltet wurde (\cite{XamNetzwerkStatus}).\\Bei
% Xamarin.iOS gibt es einen ähnlichen Mechanismus.
% \\Der Befehl \textcolor{gray}{\textsl{Reachability.InternetConectionStatus()}} liefert Auskunft
% darüber ob eine Internetverbindung über WLAN, über mobiles Internet erfolgt oder es gar keine
% Verbindung besteht (\cite{XamNetzwerkStatusIOS}). Die Netzwerktyperkennung lässt sich nicht
% plattformübergreifend implementieren, das erfolgt in den plattformspezifischen Projekten.
\section{Xamarin Komponenten (Components) und NuGet Packages} \label{nuGetPackages}
Wie in \ref{nugets} bereits erwähnt, ist die Möglichkeit, Xamarin Komponenten und NuGet Packages an
ein Projekt anzubinden, eine der größten Stärken von Xamarin.
Da zu Xamarin.Forms "`shared"' Projects keine Komponenten zum gemeinsamen Projekt
hinzugefügt werden können, müssen die benötigten Komponenten zu den
plattformspezifischen Projekten hinzugefügt werden (siehe Abb. \ref{fig:abb40}).
\subsection{Xamarin Components}
\begin{itemize}
        \item \textbf{ModernHttpClient} - Für die Kommunikation mit dem Backend wird ein Http-Client
        benötigt. Es gibt mehrere ähnliche Komponenten und NuGet Packages. \\Für die vorliegende
        Arbeit ist die Wahl auf die ModernHttpClient-Komponente gefallen, weil diese          
        vorwiegend sehr positiv in der Xamarin-Community bewertet wird und im Gegensatz zu
        anderen ähnlichen Komponenten auch mit dem Protokol Https funktioniert.
        \item \textbf{ZXing.Net.Mobile} - Die Kernfunktionalität der Nüßing ScanApp, nämlich die
        Scan-Funktion wird mithilfe der Xamarin-Komponente ZXing.Net.Mobile gewährleistet. Der
        Entwickler braucht sich nicht um native Funktionen, wie die Nutzung der Kamera und das Ein- und Ausschalten des
        Blitzlichtes, zu kümmern. Diese Funktionalität, sowie die Erkennung des Barcodes wird von der
        ZXing-Komponente bereitgestellt. 
\end{itemize}
\subsection{NuGet Packages}
\begin{itemize}
        \item \textbf{Newtonsoft.Json} - Für die Kommunikation mit dem Backend werden Json-Objekte
        benutzt.
        Damit man zu den in einem Json-Objekt enthaltenen Informationen gelangen kann, muss das Objekt
        zerteilt (geparst) werden. Das NuGet Package Newtonsoft.Json macht das Parsen eines
        Json-Objekts zu einer relativ einfache Aufgabe.
        \item \textbf{Xam.Plugin.DeviceInfo} - Beim ersten Start der Applikation, muss der Kunde sich
        einmalig registrieren. Bei der Registrierung wird auch Information über das Gerät
        mitgesendet. Zu dieser nativen Information gelangt man mithilfe des NuGet Packages,
        Xam.Plugin.DeviceInfo.
\end{itemize}
Es gibt eine große Vielfalt an Xamarin Komponenten und NuGet Packages. Somit kann eine
Xamarin Applikation mit mehreren Features angereichert werden. 
\section{Fazit}
Mit Xamarin.Forms lässt sich nicht nur die ganze App-Logik im einem Gemeinsamen Projekt
implementieren, sondern auch fast die ganze Benutzungsoberfläche der App. Daraus resultieren zwei
(oder sogar drei, wenn auch eine Windows Phone als Zielplattform erwünscht ist) Versionen der
Anwendung, die alle das native "`Look and Feel"' der jeweiligen Plattform haben. Die gemeinsame
Codebasis erleichtert nicht nur den Entwurf, sondern auch das Fixen von Bugs und die Wartung der
App. Als negative Feststellung kann an dieser angemerkt werden, dass NuGet Packages und Xamarin
Components nicht zum geteilten Projekt hinzugefügt werden können und dadurch entsteht doppelten
Aufwand (Bei dem Xamarin.Forms PCL-Ansatz ist das allerdings nicht der Fall. Da werden "`open
source"' Bibliotheken zum gemeinsamen Projekt hinzugefügt).

