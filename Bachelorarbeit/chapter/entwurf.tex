%\newpage
\section{Entwurf für die Entwicklung mit Xamarin}
In diesem Abschnitt wird der Entwurf der Nüßing ScanApp mit Xamarin.Forms beschrieben. 
Es wird das für Xamarin übliche MVVM-Muster angewendet.\\Bei Xamarin.Forms gibt es zwei alternative
Methoden zum Code-Sharing:
 Shared Projects und Portable Class Libraries (PCL). Da im vorliegenden Fall Code-Sharing nur
 innerhalb der Applikation vorgesehen wurde, wird Shared Projects gewählt (der PCL
 Ansatz wird für den Fall empfohlen, wenn ein Entwickler seinen Code für andere Developer in Form
 einer DLL Bibliothek bereitstellen möchte).
Beim Erstellen des Xamarin.Forms Projekts namens ScanApp werden automatisch zwei weitere Projekte
erstellt, so dass folgende Projekte entstehen:
\begin{itemize}
  \item ScanApp - das gemeinsame, plattformübergreifende Projekt.
  \item ScanApp.Droid - plattformspezifisches Projekt für Android.
  \item ScanApp.iOS - plattformspezifisches Projekt für iOS.
\end{itemize}
Der Großteil des Codes befindet sich im plattformübergreifenden Projekt, ScanApp. In die Projekte
ScanApp.Droid und ScanApp.iOS gehören App-Ressourcen wie bspw. Icons, sowie
benutzerdefinierte Renderer. Die sogenannten "`Custom Renderer"' werden für die Implementierung und
Gestaltung von benutzerdefinierten Steuerelementen und Ansichten benötigt, die mit den von
Xamarin.Forms zur Verfügung gestellten Werkzeugen nicht zu realisieren sind. \\Sollte eine
Anforderung nicht plattformübergreifend zu gewährleisten sein, muss diese Funktionalität in den
plattformspezifischen Projekten implementiert werden. Im gemeinsamen Projekt wird ein Interface
definiert, das von den dafür zuständigen Klassen in ScanApp.Droid und ScanApp.iOS implementiert
werden muss.
% Die angeforderte Funktionalität wird in den plattformspezifischen Projekten implementiert. Dieses
% Interface muss von den jeweiligen Klassen, die die Funktionalität gewährleisten, der plattformspezifischen Projekte implementiert.
Der Zugriff aus dem plattformübergreifenden Projekt erfolgt folgendermaßen:\\
\textcolor{gray}{\emph{DependencyService.Get<InterfaceName>().PlattformSpecificMethodName()}}.
\subsection{Umsetzung des MVVM-Architekturmusters}
Wie bereits im Kapitel \ref{MVVM} erörtert, weist das MVVM-Pattern eine lose Kopplung
zwischen View und Viewmodel auf. Um diese Trennung visuell zu gestalten, werden drei Ordner erstellt:
\begin{itemize}
  \item \textbf{Model} - Im Ordner Model werden typischerweise Klassen defniert, die
  anwendungsspezifische Datentypen beschreiben. Das sind Klassen zur Speicherung und
  Verarbeitung von Daten, die dafür sorgen, dass die Daten konsistent gehalten
  werden.
  \item \textbf{View} - Alle Ansichten (Xaml-Datein, die vom Typ Xamarin.Forms.Page oder
Xamarin.Forms.View sind oder von diesen Klassen erben) gehören in den Ordner View.
  \item \textbf{Viewmodel} - In den Viewmodel-Ordner kommen die Viewmodel-Klassen (C\#-Klassen,
  die das Interface \textbf{\textit{INotifyPropertChanged}} implementieren). 
\end{itemize}
Jede Ansicht wird an einem Viewmodel gebunden. In Abb.\ref{fig:abb23} sieht man eine typische
Xaml-Datei, die eine Ansicht beschreibt und sich im Ordner View befindet. Diese Ansicht wird
von der benutzerdefinierten Base\_Page abgeleitet, die ihrerseits von der Klasse Xamarin.Forms.Page
abgeleitet wird. In Base\_Page werden Eigenschaften und Methoden definiert, die für die meisten
Ansichten gemeinsam sind. Bspw. das Navigationsheader-Logo oder Methoden für die Steuerung
der Navigation.
\\Eine der wichtigsten Klassenvariablen der Klasse Xamarin.Forms.Page ist das Property
\textit{BindingContext}.
Mithilfe dieser Eigenschaft wird ein Viewmodel (in diesem Fall das HeaderDataEditViewModel) an der Page-Klasse gebunden (Siehe
\ref{fig:abb23}, Zeile 23-25).
\\In Zeile 12 findet eine typische Datenbindung ("`data binding"') statt.
Das Text-Property eines Entry-Textfeldes wird an das Property \textit{Name} gebunden, das im
Viewmodel definiert wird (siehe Abb.\ref{fig:abb33}).
Sobald der Text des Textfelds sich ändert, wird das Viewmodel darüber informiert. Diese Bindung
funktioniert in beiden Richtungen, d.h. Änderungen, die im Viewmodel vorgenommen werden, werden in
der Ansicht angezeigt.\\In Abbildung \ref{fig:abb23}, Zeile 20 ist die Definition eines
Toolbarbuttons zu sehen. Sobald dieser Button gedrückt wird, wird ein Command ausgeführt, das an
das Property \textit{SaveUserDataCommand} des Viewmodels gebunden ist. D.h. dieses Klick-Event
löst den Aufruf einer Methode in der Viewmodel-Klasse auf.\\Das Ganze veranschaulicht, welche
Vorteile das MVVM-Architekturmuster mit sich bringt.
Durch die Datenbindung entsteht eine lose Kopplung zwischen View und ViewModel. Da das Viewmodel die Views nicht kennt, lässt sich eine Ansicht problemlos durch eine andere austauschen. Die neue Ansicht muss lediglich an das Viewmodel gebunden werden.
\\Ein ViewModel muss zwingend das Interface \textbf{\textit{INotifyPropertChanged}} implementieren.
Dadurch können sogenannte "`Bindable Properties"` definiert werden (siehe Abb.\ref{fig:abb33}). Bei
jeder Änderung wird die
OnPropertyChanged()-Methode mit dem Property-Name als Stringparameter aufgerufen und dadurch wird
ein PropertyChangedEventHandler ausgelöst.
\\Wie bei den meisten Applikationen, sind auch für die Scan-Anwendung mehrere Ansichten erforderlich. Es stellt sich die Frage, wie wird zwischen den verschiedenen Seiten gewechselt?\\Um zwischen den Ansichten navigieren zu können, wird eine Instanz der Klasse
\textit{NavigationPage} benötigt: \textit{new NavigationPage(new Page())}. \\Jede
Xamarin.Forms.Page-Klasse hat über das Property
\textbf{\textit{Navigation}} Zugriff auf das NavigationPage: \textit{this.Navigation.PushAsync(new
Page())}.\\Nach dem MVVM-Muster sollten sich die Viewmodel-Klassen um die Navigation kümmern.
Allerdings ist \textit{Navigation} ein Property der Ansicht. D.h. das Viewmodel muss signalisieren,
dass es zu einer anderen Ansicht gewechselt werden soll. Da das Viewmodel die Ansicht nicht kennt,
kann das durch das \textbf{\textit{Xamarin.Forms Messaging Center}} erreicht werden. Die Ansicht
abonniert Navigationsnachrichten des Viewmodels und wird somit immer informiert, wenn die
Seite gewechselt werden soll.

% \begin{itemize}
%   \item Das Framework MVVM-Light
%   \item Messaging
%   \item unsaubere Anwendung von MVVM, wie z.B. das Property NavigatioPage einer Ansicht dem
%   zugehörigen ViewModel mitzugeben. Das würde die Navigation aus dem ViewModel ermöglichen, aber
%   es verletzt eine der Grundideen von MVVM ist es, dass der ViewModel die View nicht kennt.
% \end{itemize}


\begin{figure}[!h]
\centering
\includegraphics[scale = 0.435]{graphics/Typische_Xaml_Datei.png}
\caption{Typische Xaml-Datei}
\label{fig:abb23}
\end{figure}
\begin{figure}[!h]
\centering
\includegraphics[scale = 0.6]{graphics/Bindable_Property.png}
\caption{Definition von Bindable Property}
\label{fig:abb33}
\end{figure}
\subsection{Persistierung der Daten mit SQLite}
Für die Persistenz der Appdaten wird die open-source Datenbank SQLite eingesetzt.\\SQLite ist gut
geeignet für Cross-Plattform-Entwicklung, weil:
\begin{itemize}
  \item die Datenbank klein, schnell und leicht portierbar ist;
  \item der Fileformat leicht zu benutzen und plattformübergreifend ist;
  \item SQLite die meisten SQL92 Standards implementiert.
\end{itemize}
Da
beim gemeinsamen ScanApp Projekt keine Bibliotheken eingebunden werden können, muss man einen
SQLite.cs File aus Github herunterladen und in das gemeinsame Projekt kopieren. Dieser C\#-File
benutzt Compiler Direktiven um mehrere Plattformen in derselben Codebasis zu unterstützen.
\\Um SQLite in einer Xamarin.iOS oder Android Applikation benutzen zu können, muss man angeben, wo
der Datenbank File zu finden ist (es ist abhängig vom
Ziel-Plattform unterschiedlich). Für iOs und Android kann man "`Environment class"' benutzen um einen
validen Pfad zu konstruieren (siehe Abb. \ref{fig:abb27}). Mittels Compiler Direktiven lassen sich
spezielle Pfade für jede Plattform generieren.\\Um sicher zu gehen, dass der Code nicht versucht,
auf die SQLite Datenbank aus verschiedenen "`multiple Threads"' zuzugreifen wird manuel ein "`lock"'
benutzt. Z.B.\\object locker = new object();\\lock(locker)\{ Datenbankquery \};\\Alle
Datenbankzugriffe sind mit demselben "`lock"' gekapselt, wobei hier Vorsicht geboten ist. Es könnten
Deadlocks entstehen! 
\begin{figure}[!h]
\centering
\includegraphics[scale = 0.4]{graphics/SQLitePath.png}
\caption{SQLite Pfad}
\label{fig:abb27}
\end{figure}

\subsection{GUI}
Die Benutzungsoberfläche wird mit wenigen Ausnahmen im gemeinsamen Projekt, ScanApp erstellt.
Xamarin lässt Entwicklern die Wahl zwischen der Markupsprache Xaml und C\# für die Implementierung
der UIs (User Interfaces), wobei beide Techniken zum gleichen Ergebnis führen. \\Die
Positionierung der Steuerelemente und deren Funktionalität lassen sich in einer C\#-Datei
implementieren, allerdings ist der Code schwer lesbar und nicht wiederverwendbar.\\Aus diesem
Grund werden die grafischen Interfaces der ScanApp mit der Markupsprache Xaml beschrieben.
Somit wird eine strikte Trennung zwischen dem Oberflächendesign (in einer
Xaml-Datei beschrieben 
% \ref{fig:abb23}
) und der Funktionalität (in der
an der Xaml-Datei gebundenen Viewmodel-C\#-Datei implementiert 
% \ref{fig:abb26},
% \ref{fig:abb25}
) erreicht.
Diese Technik macht Wiederverwendbarkeit und Austauschbarkeit einer Ansicht möglich.
Somit können Designer und Entwickler unabhängig voneinander arbeiten. \\Bei der Erstellung einer
Xamarin.Forms ContentPage Xaml-Datei wird automatisch auch die zugrundeliegende C\#-Datei, bekannt
auch als "`Code-Behind-Datei"', angelegt (siehe Abb. \ref{fig:abb21}).
Diese Code-Behind-Datei sollte bei einer sauberen Umsetzung des MVVM-Patterns außer des Aufrufs der
\emph{InitializeComponent()} Methode im Konstruktor und der bereits erwähnten Methoden, die
Viewmodelnachrichten abonnieren und die Navigation steuern, komplett leer sein.
Es ist möglich, dass die Funktionalität eines Viewmodels in der Code-Behind-Datei einer Ansicht
untergebracht wird. Das entspricht, allerdings, nicht dem MVVM-Architekturmuster. Dadurch
würde eine sehr enge Kopplung zwischen View und Funktionalität entstehen und die Ansichten wären
nicht mehr austauschbar.
\\Der Aufbau einer Xaml-Datei ist dem Gerüst eines XML-Dokuments sehr ähnlich. Es gibt ein
Wurzelelement und jedes Element kann Attribute besitzen. Dadurch entsteht eine übersichtliche Hierarchie der Elemente
(Siehe \ref{fig:abb23}).
Durch das Attribut x:Name könnte man auf das Element aus der Code-Behind-Datei zugreifen und bspw. den
Text eines Labels oder die Textfarbe setzen. 
% (siehe \ref{fig:abb26}).
\begin{figure}[!h]
\centering
\includegraphics[scale = 0.7]{graphics/XamlDateiPlusCSDatei.png}
\caption{Xaml-Datei und die zugrundeliegende C\#-Datei}
\label{fig:abb21}
\end{figure}
% \\In Abbildung \ref{fig:abb25} sieht man die zugrundeliegenden C\#-Datei, in der z.B. die
% Funktionalität der Toolbar-Buttons implementiert ist. Beim Klick auf den Button zum Speichern der
% Angaben, werden die Texten der Texteingabefeldern in einem Objekt vom Typ Kopfdaten gespeichert und
% anschließend wird das neu erstellte Objekt in die SQLite-Datenbank gespeichert. Beim Klick auf den
% Müllkorb-Button, werden die gespeicherten persönlichen Daten aus der SQLite-Datenbank gelöscht. 
% \begin{figure}[!h]
% \centering
% \includegraphics[scale = 0.7]{graphics/XamlDateiPlusCSDatei.png}
% \caption{Xaml-Datei und die zugrundeliegende C\#-Datei}
% \label{fig:abb21}
% \end{figure}
% \begin{figure}[!h]
% \centering
% \includegraphics[scale = 0.435]{graphics/Typische_Xaml_Datei.png}
% \caption{Typische Xaml-Datei}
% \label{fig:abb23}
% \end{figure}

% \begin{figure}[!h]
% \centering
% \includegraphics[scale = 0.3]{graphics/appScreenshots/PersoenlicheDaten.png}
% \caption{Screenshot: Seite zum Editieren der persönlichen Daten eines Nutzers der ScanApp}
% \label{fig:abb24}
% \end{figure}

% \begin{figure}[!h]
% \centering
% \includegraphics[scale = 0.4]{graphics/HeaderDatenCSDatei.png}
% \caption{Zugrundeliegende (Code-Behind) C\#-Datei}
% \label{fig:abb26}
% \end{figure}


% \begin{figure}[!h]
% \centering
% \includegraphics[scale = 0.5]{graphics/HeaderDatenToolbar.png}
% \caption{Zugrundeliegende C\#-Datei}
% \label{fig:abb25}
% \end{figure}

\subsection{Entwurf der Navigation zwischen den verschiedenen Seiten der ScanApp}
Die Implementierung der Navigation der App erfolgt ausschließlich im gemeinsamen Projekt, ScanApp.
In der Startseite der App, \emph{public class App}, wird in der Datenbank überprüft ob bereits ein
Benutzer registriert wurde. Je nachdem, ob das der Fall ist oder nicht, gibt es zwei mögliche Wege:
\begin{itemize}
  \item Im Falle, dass ein Datenbankeintrag mit einem Benutzer existiert, wird der User zu einer
  Menü-Seite navigiert. Diese Menü-Seite ist vom Typ \textbf{MasterDetailPage}. An
  dieser Stelle ist wichtig zu erwähnen, dass bei Xamarin.Adroid, die Benutzung von einer
  MasterDetailPage in einer NavigationPage nicht möglich ist und die Anwendung stürzt ab. Aus
  diesem Grund wird hier folgende Compiler-Direktive zur Fallunterscheidung benutzt:
  \textcolor{gray}{
  \\ \#if \textunderscore\textunderscore iOS\textunderscore\textunderscore
   \\MainPage = new NavigationPage( new MenuMasterDetailPage());\\ \#endif}\\Für Android sieht der
   Code folgendermaßen aus:\\ \textcolor{gray}{\#if \textunderscore\textunderscore
   Android\textunderscore\textunderscore \\ MainPage = new MenuMasterDetailPage();\\ \#endif}
  \item Wenn noch kein Benutzer registriert wurde, wird eine \textbf{NavigationPage} erstellt und
  der User wird zu der \textbf{Login-Seite}, vom Typ ContentPage, navigiert (siehe
  Abb.\ref{fig:abb29}). Auf der Login-Seite gibt es außer ein paar Labels mit Hinweistexten und
  einen Registrierung-Button, zwei Entry-Felder, in denen der User seine Kundennummer und seine Postleitzahl eingeben muss. Die Daten werden zum
  Server gesendet und im Falle einer erfolgreichen Registrierung, wird zu der bereits erwähnten
  \textbf{MasterDetailPage} navigiert (siehe Abb.\ref{fig:abb31}). Wegen der bekannten Problemen bei
  Xamarin.Android zwischen NavigationPage und MasterDetailPage, muss hier wieder unterschieden werden zwischen iOS und
  Android. Bei Android muss die Navigation von Typ "`modal"' sein (ohne
  Möglichkeit zurückzunavigieren).\\\textcolor{gray}{\#if \textunderscore\textunderscore
  Android\textunderscore\textunderscore \\this.Navigation.PushModalAsync(new MenuMasterDetailPage());\\
   \#endif}
\end{itemize}


\begin{figure}[!h]
\centering
\includegraphics[scale = 0.2]{graphics/appScreenshots/ScreenShot_Login.png}
\caption{Login-Seite}
\label{fig:abb29}
\end{figure}


\begin{figure}[!h]
\centering
\includegraphics[scale = 0.2]{graphics/appScreenshots/ScreenShot_Menu.png}
\caption{Menüsteuerungsseite}
\label{fig:abb31}
\end{figure}


\subsubsection{Steuerung des Menüs mit MasterDetailPage}
In der Abb.\ref{fig:abb31} sieht man das aufgeklappte Menü der Menüsteuerungsseite der Nüßing
ScanApp. Die MasterDetailPage hat zwei wichtige Properties von Typ Page:
\begin{itemize}
  \item Master - eine ContentPage mit einem Element, nämlich eine TableView, in der die
  unterschiedlichen Navigationspunkte aufgelistet werden.
  \item Detail - je nachdem, welcher Navigationspunkt geklickt wurde, wird eine neue NavigationPage
  erstellt und der Benutzer wird zu der entsprechenden Seite (ContentPage) navigiert.
\end{itemize}
Beispielsweise sieht die Navigation zu der Kontakt-Seite folgendermaßen aus:
\\ \textcolor{gray}{\textsl{void onKontaktTapped(object sender, EventArgs e)\\ \{\\ this.Detail
= new NavigationPage(new KontaktPage());\\this.isPresent = false;
\\
\}}}
\\Die Zeile \textcolor{gray}{\textit{this.isPresent = false;}}, sorgt dafür, dass das Menü
automatisch zugeklappt wird, nachdem die ausgewählte Seite aufgemacht wurde.
\subsection{Barcodescanners}
Die Implementierung des Barcodescanners ist einer der wenigen Punkten, bei denen ein Eingriff in
die plattformspezifischen Projekte notwendig ist. Sowie zum ScanApp.iOS als auch zum ScanApp.Droid
muss die Komponente ZXing.Net.Mobile hinzugefügt werden. Im gemeinsamen Projekt wird das Interface
IScanner.cs
definiert (Abb. \ref{fig:abb28}). In beiden plattformspezifischen Projekte wird je eine Klasse
Scanner.cs erstellt, die dieses Interface implementiert. Im Projekt ScanApp kann
man auf die plattformspezifische Scanner.cs Klassen mit:\\
\textcolor{gray}{\emph{DependencyService.Get<IScanner>().Scan()}} zugreifen.
\begin{figure}[!h]
\centering
\includegraphics[scale = 0.4]{graphics/IScanner.png}
\caption{Das Interface IScanner}
\label{fig:abb28}
\end{figure}

\subsection{Web Services für die Kommunikation mit dem Backend}
Web Services kommen in den folgenden Fällen zum Einsatz:
\begin{itemize}
  \item Bei der einmaligen Registrierung eines Benutzers.
  \item Beim Überprüfen eines Barcodes.
  \item Beim Abschließen einer Bestellung.
  \item Beim Anzeigen des Kundennamen nach der Eingabe einer Kundennummer (Nur im
  Mitarbeiter-Modus).
\end{itemize} 
Im gemeinsamen Projekt wird für diesen Zweck eine Klasse mit jeweils eine Methode für die oben
genannten vier Fällen erstellt. Alle Methoden der Klasse benutzen den gleichen Http-Client der
Komponente \textbf{ModernHttpClient}:\\  
\textcolor{gray}{\emph{HttpClient client = new HttpClient(new
ModernHttpClient.NativeMessageHandler())}}.

\subsection{Xamarin Komponenten (Components) und NuGet Packages, die für die
Entwicklung der App genutzt werden}
Die Möglichkeit, Komponenten und NuGet Packages an ein Projekt anzubinden, ist eine der
größten Stärken von Xamarin.
Da bei Xamarin.Forms Shared Projects keine Komponenten zum gemeinsamen (shared) Projekt
hinzugefügt werden können, müssen die benötigten Komponenten zu den
plattformspezifischen Projekten hinzugefügt werden.
\subsubsection{Xamarin Components}
\begin{itemize}
        \item \textbf{ModernHttpClient} - Für die Kommunikation mit dem Backend wird ein Http-Client
        benötigt. Es gibt mehrere ähnliche Komponenten und NuGet Packages. \\Für die vorliegende
        Arbeit ist die Wahl auf die ModernHttpClient-Komponente gefallen, weil diese          
        vorwiegend sehr positiv in der Xamarin-Community bewertet wird und anders als andere
        ähnliche Packages auch mit dem Protokol Https funktioniert.
        \item \textbf{ZXing.Net.Mobile} - Die Kernfunktionalität der Nüßing ScanApp, nämlich die
        Scan-Funktion wird mithilfe der Xamarin-Komponente ZXing.Net.Mobile gewährleistet. Der
        Entwickler braucht sich nicht um native Funktionen, wie die Nutzung der Kamera und das Ein- und Ausschalten des
        Blitzlichtes, zu kümmern. Diese Funktionalität, sowie die Erkennung des Barcodes wird von der
        ZXing-Komponente bereitgestellt. 
\end{itemize}
\subsubsection{NuGet Packages}
\begin{itemize}
        \item \textbf{Newtonsoft.Json} - Für die Kommunikation mit dem Backend werden Json-Objekte
        benutzt.
        Damit man zu den in einem Json-Objekt enthaltenen Informationen gelangen kann, muss das Objekt
        zerteilt (geparst) werden. Das NuGet Package Newtonsoft.Json sorgt für das Parsen eines Json-Objekts.
        \item \textbf{Xam.Plugin.DeviceInfo} - Beim ersten Start der Applikation, muss der Kunde sich
        einmalig registrieren. Bei der Registrierung wird auch Information über das Gerät
        mitgesendet. Zu dieser nativen Information gelangt man mithilfe des NuGet Packages,
        Xam.Plugin.DeviceInfo.
\end{itemize}
Es gibt eine große Vielfalt an Xamarin Komponenten und NuGet Packages. Somit kann eine
Xamarin Applikation mit mehreren Features angereichert werden. 